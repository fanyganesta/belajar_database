<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Type</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>

        <main>
            <header>
                
            </header>
            
            <div class="content">
                <h2>4.3 Soft Delete vs Hard Delete</h2>

                (Strategi Menghapus Data Tanpa Menyesal di Masa Depan)

                Dalam database, menghapus data itu bukan cuma soal DELETE FROM table.
                Keputusan ini ngaruh ke:

                histori data

                audit & laporan

                relasi antar tabel

                bug misterius ğŸ˜…

                performa & biaya mental developer di masa depan

                Secara konsep, ada 2 pendekatan utama:

                <br> <hr> <br>

                <h3>A. Hard Delete</h3>

                Data benar-benar hilang dari database

                DELETE FROM users WHERE id = 10;


                Setelah ini:

                âŒ data hilang

                âŒ tidak bisa direstore

                âŒ histori ikut lenyap

                <br> <hr> <br>

                <h3>B. Soft Delete</h3>

                Data dianggap terhapus, tapi masih disimpan

                Biasanya pakai kolom seperti:

                deleted_at

                atau is_deleted

                UPDATE users SET deleted_at = NOW() WHERE id = 10;


                Secara logika:

                data masih ada

                tapi tidak dianggap aktif

                <br> <hr> <br>

                <h3>C. Kenapa Ini Penting Banget?</h3>

                Karena:

                bisnis sering minta:

                â€œeh data user kemarin bisa dibalikin gak?â€

                laporan butuh histori lama

                relasi foreign key bisa rusak kalau hard delete sembarangan

                future you bakal nyalahin past you ğŸ˜„

                <br> <hr> <br>

                Sekarang kita fokus dulu ke SOFT DELETE sesuai permintaanmu ğŸ‘‡

                <h2>4.3.1 Soft Delete</h2>

                (Menghapus Tanpa Menghilangkan Jejak)

                <br> <hr> <br>

                <h3>A. Definisi Soft Delete</h3>

                Soft delete adalah teknik:

                tidak menghapus baris, tapi menandainya sebagai terhapus

                Biasanya pakai:

                timestamp (deleted_at)

                atau flag boolean (is_deleted)

                <br> <hr> <br>

                <h3>B. Pola Paling Umum (Best Practice)</h3>
                1ï¸âƒ£ deleted_at (PALING DISARANKAN)
                deleted_at DATETIME NULL


                Kondisi:

                NULL â†’ data aktif

                ada timestamp â†’ data terhapus

                Kenapa ini cakep?

                ada waktu penghapusan

                enak buat audit

                bisa restore

                <br> <hr> <br>

                2ï¸âƒ£ is_deleted (Lebih sederhana)
                is_deleted TINYINT(1) DEFAULT 0


                Kondisi:

                0 â†’ aktif

                1 â†’ terhapus

                Kekurangan:

                gak tahu kapan dihapus

                kurang kuat buat sistem besar

                <br> <hr> <br>

                <h3>C. Contoh Implementasi Query</h3>
                Insert data normal
                INSERT INTO products (name, price)
                VALUES ('Tas Kulit', 250000);

                Soft delete data
                UPDATE products
                SET deleted_at = NOW()
                WHERE id = 5;

                Ambil data yang masih aktif
                SELECT * FROM products
                WHERE deleted_at IS NULL;

                Ambil data yang sudah terhapus
                SELECT * FROM products
                WHERE deleted_at IS NOT NULL;

                <br> <hr> <br>

                <h3>D. Dampak ke Query (INI YANG SERING KELEWAT)</h3>

                Kalau pakai soft delete:

                SEMUA SELECT harus sadar soft delete

                âŒ SALAH (berbahaya):

                SELECT * FROM orders;


                âœ… BENAR:

                SELECT * FROM orders
                WHERE deleted_at IS NULL;


                Makanya di framework (Laravel, dll):

                biasanya ada global scope

                biar aman otomatis

                <br> <hr> <br>

                <h3>E. Soft Delete & Foreign Key</h3>

                Soft delete TIDAK memicu:

                ON DELETE CASCADE

                ON DELETE RESTRICT

                Karena:

                database merasa datanya belum dihapus

                Ini bagus karena:

                relasi tetap utuh

                histori aman

                Tapi juga berarti:

                logic delete jadi tanggung jawab aplikasi

                <br> <hr> <br>

                <h3>F. Kapan Soft Delete WAJIB Dipakai?</h3>

                Soft delete cocok banget kalau:

                âœ… data user
                âœ… transaksi
                âœ… order
                âœ… pembayaran
                âœ… log aktivitas
                âœ… laporan keuangan
                âœ… sistem audit

                Prinsipnya:

                Kalau datanya penting secara bisnis â†’ soft delete

                <br> <hr> <br>

                <h3>G. Kesalahan Umum Soft Delete</h3>

                âŒ lupa filter deleted_at IS NULL
                âŒ index tidak disiapkan
                âŒ soft delete tapi FK tidak dipikirkan
                âŒ campur soft delete & hard delete tanpa aturan

                <br> <br>

                <hr>

                <br> <br>

                <h2>4.3.2 Hard Delete</h2>

                (Kapan Boleh Kejam Tanpa Dosa Database)

                Hard delete itu bukan jahat, tapi harus sadar konteks.
                Masalah muncul bukan karena hard delete, tapi karena salah tempat & salah timing.

                <br> <hr> <br>

                <h3>A. Definisi Hard Delete</h3>

                Hard delete adalah:

                menghapus baris data secara permanen dari database

                DELETE FROM logs WHERE id = 100;


                Setelah ini:

                âœ… data hilang dari tabel

                âŒ tidak bisa direstore

                âŒ histori ikut lenyap

                <br> <hr> <br>

                <h3>B. Karakteristik Hard Delete</h3>
                Aspek	Dampak
                Penyimpanan	Lebih hemat
                Query	Lebih simpel
                Restore	âŒ Tidak bisa
                Audit	âŒ Hilang
                Risiko	âš ï¸ Tinggi

                <br> <hr> <br>

                <h3>C. Kapan Hard Delete BOLEH Dipakai?</h3>

                Hard delete aman kalau datanya:

                1ï¸âƒ£ Data Teknis / Temporary

                Contoh:

                session

                cache

                OTP

                token reset password

                log error sementara

                DELETE FROM sessions WHERE expires_at < NOW();


                â¡ï¸ Tidak ada nilai historis

                <br> <hr> <br>

                2ï¸âƒ£ Data Turunan (Derived Data)

                Data hasil proses:

                temp calculation

                table staging

                hasil import sementara

                Jika data bisa:

                dibuat ulang

                dihitung ulang

                â¡ï¸ Hard delete = aman

                <br> <hr> <br>

                3ï¸âƒ£ Data Salah Input (Belum Dipakai)

                Contoh:

                order belum checkout

                draft yang tidak pernah publish

                data dummy

                Catatan penting:

                Belum pernah punya relasi ke data penting lain

                <br> <hr> <br>

                <h3>D. Kapan Hard Delete JANGAN Dipakai?</h3>

                âŒ user
                âŒ order
                âŒ invoice
                âŒ pembayaran
                âŒ laporan keuangan
                âŒ histori aktivitas
                âŒ data yang pernah â€œdipakai bisnisâ€

                Rule keras:

                Kalau data pernah dipakai ambil keputusan â†’ JANGAN HARD DELETE

                <br> <hr> <br>

                <h3>E. Hard Delete & Foreign Key</h3>

                Hard delete aktif memicu constraint:

                DELETE FROM users WHERE id = 5;


                Jika ada FK:

                RESTRICT â†’ gagal

                CASCADE â†’ data anak ikut hilang

                SET NULL â†’ relasi kosong

                âš ï¸ CASCADE itu senjata tajam
                Sekali salah â†’ satu pohon data lenyap ğŸŒ³ğŸ’¥

                <br> <hr> <br>

                <h3>F. Kesalahan Fatal yang Sering Terjadi</h3>

                âŒ pakai hard delete untuk transaksi
                âŒ CASCADE tanpa dokumentasi
                âŒ delete tanpa WHERE ğŸ˜±
                âŒ tidak backup sebelum operasi besar

                Pro tip:

                BEGIN;
                DELETE ...
                ROLLBACK; -- kalau panik

                <br> <br>

                <hr>

                <br> <br>

                <h2>4.3.3 Dampak Soft Delete vs Hard Delete</h2>

                (Ke Query & Laporan â€” Ini yang Kerasa di Dunia Nyata)

                Sekarang kita bahas efek nyatanya, bukan teori doang.

                <br> <hr> <br>

                <h3>A. Dampak ke Query</h3>
                1ï¸âƒ£ Soft Delete

                Query lebih kompleks:

                SELECT * FROM orders
                WHERE deleted_at IS NULL;


                Konsekuensi:

                semua query harus sadar soft delete

                butuh index tambahan (deleted_at)

                raw query lebih rawan lupa filter

                Tapi:

                data aman

                histori utuh

                <br> <hr> <br>

                2ï¸âƒ£ Hard Delete

                Query lebih simpel:

                SELECT * FROM orders;


                Konsekuensi:

                query cepat & bersih

                tapi data historis tidak ada

                bug laporan bisa muncul diam-diam

                <br> <hr> <br>

                <h3>B. Dampak ke JOIN</h3>
                Soft Delete
                SELECT *
                FROM orders o
                JOIN users u ON u.id = o.user_id
                WHERE o.deleted_at IS NULL
                AND u.deleted_at IS NULL;


                âš ï¸ lupa satu filter = data hantu muncul ğŸ‘»

                Hard Delete
                SELECT *
                FROM orders o
                JOIN users u ON u.id = o.user_id;


                Lebih simpel
                TAPI:

                data lama bisa hilang â†’ laporan berubah

                <br> <hr> <br>

                <h3>C. Dampak ke Laporan & Analytics</h3>
                Soft Delete

                âœ… laporan konsisten
                âœ… histori lengkap
                âœ… bisa audit
                âœ… bisa restore data lama

                Contoh:

                â€œTotal penjualan 2022 tetap sama walau ada order dibatalkan 2024â€

                Hard Delete

                âŒ angka laporan bisa berubah
                âŒ data masa lalu tidak stabil
                âŒ sulit audit
                âŒ rawan konflik dengan finance

                Contoh bahaya:

                â€œKok omzet bulan lalu turun?â€
                (padahal data dihapus)

                <br> <hr> <br>

                <h3>D. Dampak ke Mental Developer ğŸ˜„</h3>
                Tipe	Efek
                Soft Delete	Lebih mikir, tapi aman
                Hard Delete	Cepatâ€¦ sampai error

                Rule hidup:

                Query ribet masih bisa diperbaiki, data hilang gak bisa

                <br> <hr> <br>

                <h3>E. Ringkasan Cepat</h3>

                Soft Delete â†’ aman, historis, cocok data bisnis

                Hard Delete â†’ cepat, bersih, cocok data teknis

                <a href="5a-index.html" class="btn-next">5a. Index</a>
                
            </div>
        </main>
    </div>

    <script>
        fetch('layout/aside.html').then(response => response.text()).then(data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop();
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>