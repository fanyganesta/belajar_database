<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Type</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>

        <main>
            <header>
                
            </header>
            
            <div class="content">
                
                <h2>BAB 2 ‚Äî SQL Dasar (Operasional Harian)</h2>
                <h3>A. Kenapa BAB 2 ini krusial?</h3>
                
                <div class="quote"><p>Kalau BAB 1 = arsitektur & fondasi, <br>
                maka BAB 2 = alat kerja harian.</p></div>

                Di dunia nyata:
                <ul>
                    <li>70% kerja backend = SELECT</li>
                    <li>20% = INSERT / UPDATE</li>
                    <li>10% = mikir kenapa query lambat üòÑ</li>
                </ul> <br>

                BAB ini ngajarin:
                <ul>
                    <li>Cara membentuk struktur data</li>
                    <li>Cara memasukkan & mengambil data</li>
                    <li>Cara memfilter data sesuai kebutuhan bisnis</li>
                </ul>
                
                <h3>B. Pembagian Besar SQL</h3>

                SQL dibagi berdasarkan tujuan, bukan sekadar sintaks:
                <table>
                    <tr>
                        <th>Kategori</th>
                        <th>Fokus</th>
                        <th>Contoh</th>
                    </tr>
                    <tr>
                        <td>DDL</td>
                        <td>Struktur database</td>
                        <td><code>CREATE</code>, <code>ALTER</code></td>
                    </tr>
                    <tr>
                        <td>DML</td>
                        <td>Isi data</td>
                        <td><code>INSERT</code>, <code>UPDATE</code></td>
                    </tr>
                    <tr>
                        <td>DQL</td>
                        <td>Query data</td>
                        <td><code>SELECT</code></td>
                    </tr>
                    <tr>
                        <td>DCL</td>
                        <td>Hak akses</td>
                        <td><code>GRANT</code>REVOKE</td>
                    </tr>
                </table>
                <br>
                üëâ Di MySQL, SELECT sering dimasukkan ke DML/DQL, tapi mindset-nya tetap beda.

                <h2>2.1 DDL ‚Äî Data Definition Language (Structure)</h2>
                <h3>A. Apa itu DDL?</h3>

                <div class="quote"><p>DDL = perintah untuk mendefinisikan & mengubah struktur database</p></div>
                <br>

                Artinya:
                <ul>
                    <li>Bukan isi data</li>
                    <li>Tapi kerangka / wadahnya</li>
                </ul> <br>
                
                Analoginya:
                <ul>
                    <li>DDL = arsitek & tukang bangunan</li>
                    <li>DML = pengisi barang</li>
                </ul> <br>
                

                

                <h3>B. Apa saja yang diatur oleh DDL?</h3>

                Dengan DDL kamu mengatur:
                <ul>
                    <li>Tabel</li>
                    <li>Kolom</li>
                    <li>Tipe data</li>
                    <li>Primary key</li>
                    <li>Foreign key</li>
                    <li>Index</li>
                    <li>Constraint (<code>UNIQUE</code>, <code>NOT NULL</code>)</li>
                </ul> <br>
                
                üìå Sekali salah desain di DDL ‚Üí efeknya panjang

                <h3>C. Karakteristik DDL (PENTING)</h3>
                <h4>1. Mengubah struktur permanen</h4>
<pre>
    CREATE TABLE users (...);
</pre>

                Begitu dijalankan:
                <ul>
                    <li>Struktur berubah</li>
                    <li>Tidak bisa ‚Äúundo‚Äù tanpa drop/alter lagi</li>
                </ul>

                <h4>2. Biasanya jarang dijalankan di production</h4>
                <ul>
                    <li>Local / development: sering</li>
                    <li>Production: sangat hati-hati, karena:</li>
                    <ul>
                        <li><code>ALTER TABLE</code> besar ‚Üí bisa lock table</li>
                        <li><code>DROP TABLE</code> = goodbye data üëã</li>
                    </ul>
                </ul>

                <h4>3. DDL = keputusan arsitektur</h4>

                Contoh keputusan DDL:
                <ul>
                    <li>Pakai <code>INT</code> atau <code>BIGINT</code></li>
                    <li>Pakai <code>ENUM</code> atau <code>lookup</code></li>
                    <li>Pakai index atau tidak</li>
                </ul> <br>
                
                Ini bukan sekadar teknis, tapi keputusan jangka panjang

                <h3>D. Komponen utama DDL (yang akan kita dalami)</h3>

                Di BAB 2.1, kita fokus ke: <br> <br>

                1Ô∏è‚É£ CREATE TABLE <br>
                ‚Üí membuat struktur awal <br> <br>

                2Ô∏è‚É£ ALTER TABLE <br>
                ‚Üí mengubah struktur yang sudah ada <br> <br>

                3Ô∏è‚É£ DROP <br>
                ‚Üí menghapus struktur <br> <br>

                4Ô∏è‚É£ INDEX & UNIQUE <br>
                ‚Üí optimasi & constraint data <br> <br>

                üî• Profesional backend dinilai dari seberapa aman dan rapi DDL-nya

                <h3>E. Mindset penting sebelum nulis DDL</h3>

                Sebelum ngetik SQL, tanyakan:
                <ul>
                    <li>Data ini bakal tumbuh seberapa besar?</li>
                    <li>Kolom ini wajib atau boleh kosong?</li>
                    <li>Apakah akan sering dipakai di WHERE / JOIN?</li>
                    <li>Apakah kemungkinan berubah di masa depan?</li>
                </ul> <br>
                
                DDL yang baik:
                <ul>
                    <li>Minim ALTER di kemudian hari</li>
                    <li>Struktur jelas</li>
                    <li>Tidak over-engineering</li>
                </ul>
                
                <h3>F. Contoh mental model DDL</h3>
                Buruk ‚ùå
<pre>
    CREATE TABLE users ( <br>
        id INT, <br>
        name TEXT, <br>
        age VARCHAR(10) <br>
    );
</pre>

                Masalah:
                <ul>
                    <li>Tidak ada PK</li>
                    <li>Tipe data asal</li>
                    <li>Tidak scalable</li>
                </ul> <br>
                
                Lebih benar ‚úÖ
<pre>
    CREATE TABLE users ( <br>
        id INT AUTO_INCREMENT PRIMARY KEY, <br>
        name VARCHAR(100) NOT NULL, <br>
        age TINYINT UNSIGNED <br>
    );
</pre>

                Struktur:
                <ul>
                    <li>Jelas</li>
                    <li>Aman</li>
                    <li>Masuk akal</li>
                </ul>

                <h3>G. Ringkasan 2.1 DDL</h3>
                <ul>
                    <li>DDL = fondasi rumah</li>
                    <li>DML = isi rumah</li>
                    <li>SELECT = cara cari barang di rumah</li>
                </ul> <br>
                
                Kalau fondasi salah:
                <ul>
                    <li>Query ribet</li>
                    <li>Data tidak konsisten</li>
                    <li>Performa buruk</li>
                </ul>
                

                <br> <br>

                <hr>

                <br> <br>


                <h2>2.1.1 CREATE TABLE ‚Äî Fondasi Semua Query</h2>
                <h3>A. Apa itu CREATE TABLE?</h3>

                <div class="quote"><p>CREATE TABLE digunakan untuk membuat struktur tabel baru di database.</p></div> <br>

                ‚ö†Ô∏è Ingat: ini bukan isi data, tapi wadah data <br> <br>

                Kalau tabel sudah salah dari awal:
                <ul>
                    <li><code>INSERT</code> ribet</li>
                    <li><code>UPDATE</code> rawan bug</li>
                    <li><code>SELECT</code> berat</li>
                </ul>
                
                <br> <hr> <br>

                <h3>B. Struktur Dasar CREATE TABLE</h3>

                Bentuk paling umum:
<pre>
    CREATE TABLE nama_tabel ( <br>
        nama_kolom tipe_data constraint, <br>
        nama_kolom tipe_data constraint, <br>
        ... <br>
    );
</pre>

                Contoh sederhana:
<pre>
    CREATE TABLE users ( <br>
        id INT, <br>
        name VARCHAR(100) <br>
    );
</pre>

                üëâ Ini valid, tapi belum profesional.

                <h3>C. Komponen Penting CREATE TABLE (WAJIB PAHAM)</h3>
                1Ô∏è‚É£ Nama Tabel <br> <br>

                Best practice:
                <ul>
                    <li>plural</li>
                    <li>snake_case</li>
                    <li>jelas secara bisnis</li>
                </ul>
                
                ‚úÖ <code>users</code>, <code>orders</code>, <code>order_items</code> <br>
                ‚ùå <code>User</code>, <code>tblUser</code>, <code>data1</code>

                2Ô∏è‚É£ Kolom

                Setiap kolom harus menjawab:
                <ul>
                    <li>Menyimpan data apa?</li>
                    <li>Tipe datanya apa?</li>
                    <li>Wajib atau tidak?</li>
                </ul> <br>
                 
                Contoh:
<pre>
    name VARCHAR(100) NOT NULL
</pre>


                3Ô∏è‚É£ Tipe Data <br> <br>

                Sudah kamu pelajari di BAB 1.2, contoh:
                <ul>
                    <li><code>INT</code></li>
                    <li><code>VARCHAR(255)</code></li>
                    <li><code>DECIMAL(10,2)</code></li>
                    <li><code>DATETIME</code></li>
                </ul> <br>
                
                DDL bagus = tipe data pas, tidak berlebihan <br> <br> <br>

                4Ô∏è‚É£ Constraint (aturan) <br>
                Constraint paling sering dipakai:
                <ul>
                    <li><code>PRIMARY KEY</code></li>
                    <li><code>NOT NULL</code></li>
                    <li><code>UNIQUE</code></li>
                    <li><code>DEFAULT</code></li>
                    <li><code>AUTO_INCREMENT</code></li>
                </ul> <br>

                Contoh:
<pre>
    id INT AUTO_INCREMENT PRIMARY KEY
</pre>
                <br> <hr> <br>

                <h3>D. CREATE TABLE Versi Profesional (Contoh Nyata)</h3>
<pre>
    CREATE TABLE users ( <br>
        id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, <br>
        email VARCHAR(150) NOT NULL UNIQUE, <br>
        name VARCHAR(100) NOT NULL, <br>
        password VARCHAR(255) NOT NULL, <br>
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP <br>
    );
</pre>

                Kenapa ini bagus:
                <ul>
                    <li>PK jelas</li>
                    <li>Email unik</li>
                    <li>Password aman</li>
                    <li>Timestamp otomatis</li>
                </ul>
                
                <br> <hr> <br>

                <h3>E. Primary Key di CREATE TABLE</h3>
                Cara 1: Inline (paling sering)
<pre>
    id INT AUTO_INCREMENT PRIMARY KEY
</pre>
<br>
                Cara 2: Di bawah (composite key)
<pre>
    CREATE TABLE order_items ( <br>
        order_id INT, <br>
        product_id INT, <br>
        quantity INT, <br>
        PRIMARY KEY (order_id, product_id) <br>
    );
</pre>

                Dipakai saat:
                <ul>
                    <li>Many-to-many</li>
                    <li>Tidak perlu id auto increment</li>
                </ul>
                
                <br> <hr> <br>

                <h3>F. DEFAULT Value</h3>

                Dipakai untuk:
                <ul>
                    <li>Nilai awal</li>
                    <li>Data sistem</li>
                    <li><code>status VARCHAR(20) DEFAULT 'pending'</code></li>
                    <li><code>is_active BOOLEAN DEFAULT 1</code></li>
                </ul>
                
                <br> <hr> <br>

                <h3>G. AUTO_INCREMENT (catatan penting)</h3>
                <ul>
                    <li>Hanya boleh satu per tabel</li>
                    <li>Biasanya di Primary Key</li>
                    <li>Jangan dipakai untuk data bisnis</li>
                </ul> <br>

                ‚ùå invoice_number AUTO_INCREMENT <br>
                ‚úÖ id AUTO_INCREMENT

                <br> <hr> <br>

                <h3>H. ENGINE & CHARSET (LEVEL PRO)</h3>

                Kalau mau rapi:
<pre>
    CREATE TABLE users ( <br>
        id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, <br>
        email VARCHAR(150) NOT NULL UNIQUE <br>
    ) ENGINE=InnoDB <br>
    CHARSET=utf8mb4;
</pre>

                Kenapa?
                <ul>
                    <li>InnoDB ‚Üí support transaction & FK</li>
                    <li>utf8mb4 ‚Üí emoji & karakter internasional</li>
                </ul>

                <br> <hr> <br>

                <h3>I. Kesalahan Umum Pemula (hindari ini)</h3>

                ‚ùå Pakai TEXT untuk semua string <br>
                ‚ùå Tidak pakai PK <br>
                ‚ùå Semua kolom boleh NULL <br>
                ‚ùå Nama kolom ambigu (data, value)

                <br> <hr> <br>

                <h3>J. Checklist CREATE TABLE (ingat ini)</h3>

                Sebelum execute, cek:
                <ul>
                    <li>Ada Primary Key?</li>
                    <li>Tipe data pas?</li>
                    <li>Kolom wajib pakai NOT NULL?</li>
                    <li>Default value masuk akal?</li>
                    <li>Nama konsisten?</li>
                </ul>
                
                <br> <hr> <br>

                <h3>K. Mini Latihan üî•</h3>

                Coba desain tabel products dengan kebutuhan:
                <ul>
                    <li>id</li>
                    <li>name</li>
                    <li>price</li>
                    <li>stock</li>
                    <li>is_active</li>
                    <li>created_at</li>
                </ul>
                
                Tulis SQL-nya (versi kamu).

                <br>
                <br>

                <hr>

                <br>
                <br>

                <h2>2.1.2 ALTER TABLE ‚Äî Mengubah Struktur Tanpa Bikin Bencana</h2>
                <h3>A. Apa itu ALTER TABLE?</h3>

                ALTER TABLE dipakai untuk mengubah struktur tabel yang SUDAH ADA.

                Yang bisa diubah:
                <ul>
                    <li>tambah kolom</li>
                    <li>ubah kolom</li>
                    <li>hapus kolom</li>
                    <li>tambah / hapus constraint</li>
                    <li>tambah index</li>
                </ul>
                
                <br>
                
                üìå Data lama tetap ada, tapi:
                <ul>
                    <li>salah ALTER = data rusak atau aplikasi error</li>
                </ul>

                <br> <hr> <br>

                <h3>B. Kenapa ALTER TABLE itu sensitif?</h3>

                Karena:
                <ul>
                    <li>tabel bisa berisi jutaan row</li>
                    <li><code>ALTER</code> bisa lock table</li>
                    <li>aplikasi bisa down sementara</li>
                </ul> <br>

                Makanya:
<pre>
    ALTER TABLE = pisau bedah, bukan palu üî™
</pre>


                <h3>C. Pola Dasar ALTER TABLE</h3>
<pre>
    ALTER TABLE nama_tabel <br>
        aksi perubahan;
</pre>

                Contoh:
<pre>
    ALTER TABLE users <br>
    ADD phone VARCHAR(20);
</pre>
                <br> <hr> <br>

                <h3>D. Tambah Kolom (ADD)</h3>
                1Ô∏è‚É£ Tambah kolom biasa
<pre>
    ALTER TABLE users <br>
    ADD age TINYINT UNSIGNED;
</pre>

                Default:
                <ul>
                    <li>NULL</li>
                    <li>posisi di akhir</li>
                </ul>
                <br> <br>

                

                2Ô∏è‚É£ Tambah kolom + constraint
<pre>
    ALTER TABLE users <br>
    ADD is_active BOOLEAN NOT NULL DEFAULT 1;
</pre>

                ‚ö†Ô∏è Wajib pakai DEFAULT kalau tabel sudah ada data <br> <br>

                3Ô∏è‚É£ Tentukan posisi kolom (opsional)
<pre>
    ALTER TABLE users <br>
    ADD phone VARCHAR(20) AFTER email;
</pre>

                Catatan: posisi kolom tidak berpengaruh ke performa

                <br> <hr> <br>

                <h3>E. Ubah Kolom (MODIFY vs CHANGE)</h3>
                üî• Ini sering bikin bingung <br>
                1Ô∏è‚É£ MODIFY (ubah tipe / constraint)
<pre>
    ALTER TABLE users
    MODIFY name VARCHAR(150) NOT NULL;
</pre>

                Nama kolom tetap <br> <br>

                Bisa ubah:
                <ul>
                    <li>tipe data</li>
                    <li>panjang</li>
                    <li>NULL / NOT NULL</li>
                </ul>
                

                2Ô∏è‚É£ CHANGE (ubah nama + definisi)
<pre>
    ALTER TABLE users <br>
    CHANGE name full_name VARCHAR(150) NOT NULL;
</pre>

                ‚ö†Ô∏è Wajib tulis ulang seluruh definisi kolom <br> <br>

                Kapan pakai apa?
                <ul>
                    <li>Ubah tipe ‚Üí MODIFY</li>
                    <li>Ganti nama kolom ‚Üí CHANGE</li>
                </ul>
                
                <br> <hr> <br>

                <h3>F. Hapus Kolom (DROP COLUMN)</h3>
<pre>
    ALTER TABLE users <br>
    DROP COLUMN phone;
</pre>

                ‚ö†Ô∏è PERINGATAN:
                <ul>
                    <li>Data hilang permanen</li>
                    <li>Tidak bisa rollback</li>
                    <li>Pastikan kolom benar-benar tidak dipakai aplikasi</li>
                </ul>
                
                <br> <hr> <br>

                <h3>G. Tambah & Hapus Constraint</h3>
                1Ô∏è‚É£ UNIQUE
<pre>
    ALTER TABLE users <br>
    ADD UNIQUE (email);
</pre>

                Hapus:
<pre>
    ALTER TABLE users <br>
    DROP INDEX email;
</pre>

                2Ô∏è‚É£ FOREIGN KEY

                Tambah:
<pre>
    ALTER TABLE orders <br>
    ADD CONSTRAINT fk_orders_user <br>
    FOREIGN KEY (user_id) REFERENCES users(id);
</pre>

                Hapus:
<pre>
    ALTER TABLE orders <br>
    DROP FOREIGN KEY fk_orders_user;
</pre>
                <br> <hr> <br>

                <h3>H. Rename Table</h3>
<pre>
    ALTER TABLE users
    RENAME TO customers;
</pre>

                ‚ö†Ô∏è Pastikan:
                <ul>
                    <li>kode aplikasi ikut diubah</li>
                    <li>query JOIN aman</li>
                </ul>
                
                <br> <hr> <br>

                <h3>I. Multiple Changes Sekaligus</h3>

                Bisa, tapi hati-hati:
<pre>
    ALTER TABLE users <br>
    ADD phone VARCHAR(20), <br>
    MODIFY name VARCHAR(150), <br>
    DROP COLUMN age;
</pre>

                Best practice:
                <ul>
                    <li>Production ‚Üí satu perubahan per ALTER</li>
                    <li>Development ‚Üí boleh digabung</li>
                </ul>
                
                <br> <hr> <br>

                <h3>J. Kesalahan Fatal Pemula ‚ùå</h3>

                ‚ùå ALTER tanpa backup <br>
                ‚ùå DROP COLUMN asal <br>
                ‚ùå Ubah tipe data tanpa cek existing data <br>
                ‚ùå Tambah NOT NULL tanpa DEFAULT

                <br> <hr> <br>

                <h3>K. Checklist Aman ALTER TABLE</h3>

                Sebelum execute:
                <ul>
                    <li>Sudah backup?</li>
                    <li>Cek data existing?</li>
                    <li>Apakah aplikasi pakai kolom ini?</li>
                    <li>Ada downtime?</li>
                </ul>
                
                <br> <hr> <br>

                <h3>L. Mini Latihan üî•</h3>

                Kondisi:
                <ul>
                    <li>Tabel products sudah ada:</li>
<pre>
    id, name, price
</pre>
                </ul> <br>

                Tugas:
                <ul>
                    <li>Tambah kolom stock (INT, default 0)</li>
                    <li>Ubah price jadi DECIMAL(12,2)</li>
                    <li>Tambah UNIQUE ke name</li>
                    <li>Tulis SQL ALTER-nya.</li>
                </ul>
                

                <br> <br>

                <hr>

                <br> <br>

                <h2>2.1.3 DROP ‚Äî Menghapus Struktur (Bukan Data Saja)</h2>
                <h3>A. Apa itu DROP?</h3>

                <div class="quote"><p>DROP adalah perintah untuk menghapus objek database secara permanen.</p></div> <br>

                <p>Yang bisa di-DROP:
                <ul>
                    <li><code></code></li>
                    <li><code>TABLE</code></li>
                    <li><code>DATABASE</code></li>
                    <li><code>INDEX</code></li>
                    <li><code>VIEW</code></li>
                    <li><code>FOREIGN KEY</code></li>
                </ul> <br>
                
                ‚ö†Ô∏è DROP = permanen
                <ul>
                    <li>Tidak ada recycle bin</li>
                    <li>Tidak ada undo</li>
                    <li>Data + struktur lenyap</li>
                </ul> </p>

                <br> <hr> <br>

                <h3>B. DROP vs DELETE (JANGAN KETUKER)</h3>
                <table>
                    <tr>
                        <th>Perintah</th>
                        <th>Yang Dihapus</th>
                        <th>Bisa Rollback</th>
                    </tr>
                    <tr>
                        <td><code>DELETE</code></td>
                        <td>Data (row)</td>
                        <td>Bisa (dalam transaction)</td>
                    </tr>
                    <tr>
                        <td>DROP<code></code></td>
                        <td>Struktur + data	</td>
                        <td>‚ùå Tidak</td>
                    </tr>
                </table>
                
                <br>

<pre>
    DELETE FROM users; -- hapus data <br>
    DROP TABLE users;  -- hapus tabelnya
</pre>
                		
                <br> <hr> <br>

                <h3>C. DROP TABLE</h3>
                <p>Sintaks dasar</p>
<pre>
    DROP TABLE users;
</pre> <br>

                <p>Efek:
                <ul>
                    <li>Tabel hilang</li>
                    <li>Semua data hilang</li>
                    <li>Index & constraint ikut hilang</li>
                </ul> </p>
            
<pre>
                DROP IF EXISTS (aman)
                DROP TABLE IF EXISTS users;
</pre>

                <p>Best practice:
                <ul>
                    <li>Hindari error</li>
                    <li>Aman di migration script</li>
                </ul></p>
                
                <br> <hr> <br>

                <h3>D. DROP DATABASE (‚ö†Ô∏è PALING BERBAHAYA)</h3>
<pre>
    DROP DATABASE my_app;
</pre>

                <p>üî• Ini menghapus semua tabel di dalamnya <br> <br>

                Biasanya:   
                <ul>
                    <li>Hanya dipakai di local / testing</li>
                    <li>Hampir tidak pernah di production</li>
                </ul></p>
                
                <br> <hr> <br>

                <h3>E. DROP INDEX</h3>

                <p>Index bisa dihapus tanpa hapus tabel.</p>
<pre>
    DROP INDEX idx_email ON users;
</pre>

                <p>Dipakai jika:
                <ul>
                    <li>Index tidak kepakai</li>
                    <li>Over-indexing</li>
                    <li>Query berubah</li>
                </ul></p>
                
                <br> <hr> <br>

                <h3>F. DROP FOREIGN KEY</h3>

                <p>Harus pakai constraint name:</p>
<pre>
    ALTER TABLE orders <br>
    DROP FOREIGN KEY fk_orders_user;
</pre>

                <p>‚ö†Ô∏è FK tidak bisa di-drop pakai DROP TABLE langsung kalau masih direferensikan.</p>

                <br> <hr> <br>

                <h3>G. Truncate vs Drop (sering disalahpahami)</h3>
                <p>TRUNCATE</p>
<pre>
    TRUNCATE TABLE users;
</pre>
                <ul>
                    <li>Hapus semua data</li>
                    <li>Struktur tetap</li>
                    <li>Lebih cepat dari <code>DELETE</code></li>
                    <li>AUTO_INCREMENT reset</li>
                </ul> <br> <br>                

                <p>DROP</p>
<pre>
    DROP TABLE users;
</pre>
                <ul>
                    <li>Struktur + data hilang</li>
                    <li>Tidak bisa dipakai lagi</li>
                </ul>
                
                <br> <hr> <br>

                <h3>H. Kapan DROP itu masuk akal?</h3>

                <p>DROP MASUK AKAL jika:
                <ul>
                    <li>Refactor besar</li>
                    <li>Migration salah</li>
                    <li>Reset database dev</li>
                    <li>Hapus fitur sepenuhnya</li>
                </ul> <br>
                
                DROP TIDAK MASUK AKAL jika:
                <ul>
                    <li>Cuma mau hapus data</li>
                    <li>Production tanpa backup</li>
                    <li>Tabel masih dipakai</li>
                </ul></p>

                <br> <hr> <br>

                <h3>I. Kesalahan Fatal yang Pernah Terjadi di Dunia Nyata üò¨</h3>

                <p>Salah konek DB (prod vs dev) <br> <br>

                Jalankan:</p>
<pre>
    DROP TABLE users;
</pre>
                <ul>
                    <li>Done. User hilang semua</li>
                </ul>
                

                <p>Makanya senior selalu:
                <ul>
                    <li>Cek database aktif</li>
                    <li>Pakai IF EXISTS</li>
                    <li>Backup dulu</li>
                </ul></p>
                
                <br> <hr> <br>

                <h3>J. Checklist Aman sebelum DROP</h3>

                <p>Sebelum tekan Enter:
                <ul>
                    <li>Ini DB yang benar?</li>
                    <li>Sudah backup?</li>
                    <li>Ini memang mau dihapus total?</li>
                    <li>Tidak ada FK dependency?</li>
                </ul></p>
                
                <br> <hr> <br>

                <h3>K. Mini Latihan üî•</h3>

                <p>Jawab cepat (tanpa SQL):
                <ul>
                    <li>Mana yang lebih berbahaya: DROP TABLE atau TRUNCATE?</li>
                    <li>Kapan kamu tidak boleh pakai DROP?</li>
                    <li>Kenapa DROP DATABASE hampir tidak pernah dipakai di production?</li>
                </ul></p>

                <br> <br>

                <hr>

                <br> <br>

                2.1.4 INDEX & UNIQUE ‚Äî Performa & Integritas Data
                A. Kenapa INDEX & UNIQUE itu penting?

                Tanpa index:

                Query lambat

                Table scan ke semua row

                Makin besar data ‚Üí makin sakit

                Tanpa UNIQUE:

                Data kotor

                Duplicate masuk

                Bug bisnis muncul diam-diam

                üî• Index = performa
                üî• Unique = kebenaran data

                B. Apa itu INDEX?

                INDEX = struktur data tambahan (biasanya B-Tree)
                yang bikin MySQL menemukan data lebih cepat.

                Analogi:

                Tanpa index ‚Üí baca buku dari halaman 1

                Dengan index ‚Üí langsung ke halaman tujuan

                C. Kolom yang Cocok Di-Index

                Index WAJIB dipertimbangkan jika kolom sering:

                dipakai di WHERE

                dipakai di JOIN

                dipakai di ORDER BY

                Contoh:

                SELECT * FROM users WHERE email = 'a@b.com';


                üëâ email kandidat index

                D. Membuat INDEX
                1Ô∏è‚É£ INDEX biasa
                CREATE INDEX idx_users_email ON users(email);


                atau via ALTER:

                ALTER TABLE users
                ADD INDEX idx_users_email (email);

                2Ô∏è‚É£ INDEX multi-kolom (composite)
                CREATE INDEX idx_orders_user_date
                ON orders(user_id, created_at);


                Urutan penting:

                (user_id, created_at) ‚â† (created_at, user_id)

                üìå Paling kiri paling penting (left-most rule)

                E. Apa itu UNIQUE?

                UNIQUE = constraint + index

                Artinya:

                Data harus unik

                MySQL otomatis bikin index

                Contoh:

                ALTER TABLE users
                ADD UNIQUE (email);


                ‚ùå Insert email sama ‚Üí ERROR

                F. UNIQUE vs INDEX Biasa
                Aspek	INDEX	UNIQUE
                Performa	‚úÖ	‚úÖ
                Cegah duplikasi	‚ùå	‚úÖ
                Cocok untuk	pencarian	identitas data
                G. PRIMARY KEY = INDEX + UNIQUE + NOT NULL
                id INT PRIMARY KEY


                Itu artinya:

                Unik

                Tidak boleh NULL

                Terindex otomatis

                H. Index yang HARUS kamu hindari ‚ùå

                ‚ùå Index di kolom:

                BOOLEAN

                gender

                is_active

                Kenapa?

                Terlalu sedikit variasi

                Index tidak efektif

                I. Over-Indexing (penyakit pemula)

                Masalah:

                INSERT / UPDATE jadi lambat

                Storage membengkak

                Maintenance berat

                Rule of thumb:

                Index hanya untuk query nyata, bukan asumsi

                J. Hapus INDEX
                DROP INDEX idx_users_email ON users;


                Gunakan kalau:

                Query berubah

                Index tidak kepakai

                K. Cara Berpikir Profesional soal INDEX

                Sebelum bikin index, tanya:

                Query apa yang paling sering?

                Kolom mana di WHERE?

                Data besar atau kecil?

                Index mengikuti query, bukan sebaliknya.

                L. Contoh Kasus Nyata

                Query:

                SELECT *
                FROM orders
                WHERE user_id = 10
                ORDER BY created_at DESC
                LIMIT 10;


                Index terbaik:

                CREATE INDEX idx_orders_user_created
                ON orders(user_id, created_at);


                üî• Cepat + optimal

                M. Mini Latihan üî•

                Tabel users punya kolom:

                id

                email

                username

                is_active

                created_at

                Jawab:

                Kolom mana wajib UNIQUE?

                Kolom mana cocok di-INDEX?

                Kolom mana tidak perlu index?

                N. Ringkasan BAB 2.1
                Topik	Inti
                CREATE TABLE	Fondasi struktur
                ALTER TABLE	Perubahan aman
                DROP	Tombol merah
                INDEX	Performa
                UNIQUE	Integritas

                üî• Kalau 2.1 ini kamu kuasai, kamu sudah siap kerja backend beneran
                
                <a href="2b-dml.html" class="btn-next">2b. DDL</a>
            </div>
        </main>
    </div>

    <script>
        fetch('layout/aside.html').then(response => response.text()).then(data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop();
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>