<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Type</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>

        <main>
            <header>
                
            </header>
            
            <div class="content">
                BAB 2 ‚Äî SQL Dasar (Operasional Harian)
                A. Kenapa BAB 2 ini krusial?

                Kalau BAB 1 = arsitektur & fondasi,
                maka BAB 2 = alat kerja harian.

                Di dunia nyata:

                70% kerja backend = SELECT

                20% = INSERT / UPDATE

                10% = mikir kenapa query lambat üòÑ

                BAB ini ngajarin:

                Cara membentuk struktur data

                Cara memasukkan & mengambil data

                Cara memfilter data sesuai kebutuhan bisnis

                B. Pembagian Besar SQL

                SQL dibagi berdasarkan tujuan, bukan sekadar sintaks:

                Kategori	Fokus	Contoh
                DDL	Struktur database	CREATE, ALTER
                DML	Isi data	INSERT, UPDATE
                DQL	Query data	SELECT
                DCL	Hak akses	GRANT, REVOKE

                üëâ Di MySQL, SELECT sering dimasukkan ke DML/DQL, tapi mindset-nya tetap beda.

                2.1 DDL ‚Äî Data Definition Language (Structure)
                A. Apa itu DDL?

                DDL = perintah untuk mendefinisikan & mengubah struktur database

                Artinya:

                Bukan isi data

                Tapi kerangka / wadahnya

                Analoginya:

                DDL = arsitek & tukang bangunan

                DML = pengisi barang

                B. Apa saja yang diatur oleh DDL?

                Dengan DDL kamu mengatur:

                Tabel

                Kolom

                Tipe data

                Primary key

                Foreign key

                Index

                Constraint (UNIQUE, NOT NULL)

                üìå Sekali salah desain di DDL ‚Üí efeknya panjang

                C. Karakteristik DDL (PENTING)
                1. Mengubah struktur permanen
                CREATE TABLE users (...);


                Begitu dijalankan:

                Struktur berubah

                Tidak bisa ‚Äúundo‚Äù tanpa drop/alter lagi

                2. Biasanya jarang dijalankan di production

                Local / development: sering

                Production: sangat hati-hati

                Karena:

                ALTER TABLE besar ‚Üí bisa lock table

                DROP TABLE = goodbye data üëã

                3. DDL = keputusan arsitektur

                Contoh keputusan DDL:

                Pakai INT atau BIGINT

                Pakai ENUM atau lookup

                Pakai index atau tidak

                Ini bukan sekadar teknis, tapi keputusan jangka panjang

                D. Komponen utama DDL (yang akan kita dalami)

                Di BAB 2.1, kita fokus ke:

                1Ô∏è‚É£ CREATE TABLE

                ‚Üí membuat struktur awal

                2Ô∏è‚É£ ALTER TABLE

                ‚Üí mengubah struktur yang sudah ada

                3Ô∏è‚É£ DROP

                ‚Üí menghapus struktur

                4Ô∏è‚É£ INDEX & UNIQUE

                ‚Üí optimasi & constraint data

                üî• Profesional backend dinilai dari seberapa aman dan rapi DDL-nya

                E. Mindset penting sebelum nulis DDL

                Sebelum ngetik SQL, tanyakan:

                Data ini bakal tumbuh seberapa besar?

                Kolom ini wajib atau boleh kosong?

                Apakah akan sering dipakai di WHERE / JOIN?

                Apakah kemungkinan berubah di masa depan?

                DDL yang baik:

                Minim ALTER di kemudian hari

                Struktur jelas

                Tidak over-engineering

                F. Contoh mental model DDL
                Buruk ‚ùå
                CREATE TABLE users (
                    id INT,
                    name TEXT,
                    age VARCHAR(10)
                );


                Masalah:

                Tidak ada PK

                Tipe data asal

                Tidak scalable

                Lebih benar ‚úÖ
                CREATE TABLE users (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    name VARCHAR(100) NOT NULL,
                    age TINYINT UNSIGNED
                );


                Struktur:

                Jelas

                Aman

                Masuk akal

                G. Ringkasan 2.1 DDL

                DDL = fondasi rumah
                DML = isi rumah
                SELECT = cara cari barang di rumah

                Kalau fondasi salah:

                Query ribet

                Data tidak konsisten

                Performa buruk


                <br> <br>

                <hr>

                <br> <br>


                2.1.1 CREATE TABLE ‚Äî Fondasi Semua Query
                A. Apa itu CREATE TABLE?

                CREATE TABLE digunakan untuk membuat struktur tabel baru di database.

                ‚ö†Ô∏è Ingat: ini bukan isi data, tapi wadah data

                Kalau tabel sudah salah dari awal:

                INSERT ribet

                UPDATE rawan bug

                SELECT berat

                B. Struktur Dasar CREATE TABLE

                Bentuk paling umum:

                CREATE TABLE nama_tabel (
                    nama_kolom tipe_data constraint,
                    nama_kolom tipe_data constraint,
                    ...
                );


                Contoh sederhana:

                CREATE TABLE users (
                    id INT,
                    name VARCHAR(100)
                );


                üëâ Ini valid, tapi belum profesional.

                C. Komponen Penting CREATE TABLE (WAJIB PAHAM)
                1Ô∏è‚É£ Nama Tabel

                Best practice:

                plural

                snake_case

                jelas secara bisnis

                ‚úÖ users, orders, order_items
                ‚ùå User, tblUser, data1

                2Ô∏è‚É£ Kolom

                Setiap kolom harus menjawab:

                Menyimpan data apa?

                Tipe datanya apa?

                Wajib atau tidak?

                Contoh:

                name VARCHAR(100) NOT NULL

                3Ô∏è‚É£ Tipe Data

                Sudah kamu pelajari di BAB 1.2, contoh:

                INT

                VARCHAR(255)

                DECIMAL(10,2)

                DATETIME

                DDL bagus = tipe data pas, tidak berlebihan

                4Ô∏è‚É£ Constraint (aturan)

                Constraint paling sering dipakai:

                PRIMARY KEY

                NOT NULL

                UNIQUE

                DEFAULT

                AUTO_INCREMENT

                Contoh:

                id INT AUTO_INCREMENT PRIMARY KEY

                D. CREATE TABLE Versi Profesional (Contoh Nyata)
                CREATE TABLE users (
                    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                    email VARCHAR(150) NOT NULL UNIQUE,
                    name VARCHAR(100) NOT NULL,
                    password VARCHAR(255) NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );


                Kenapa ini bagus:

                PK jelas

                Email unik

                Password aman

                Timestamp otomatis

                E. Primary Key di CREATE TABLE
                Cara 1: Inline (paling sering)
                id INT AUTO_INCREMENT PRIMARY KEY

                Cara 2: Di bawah (composite key)
                CREATE TABLE order_items (
                    order_id INT,
                    product_id INT,
                    quantity INT,
                    PRIMARY KEY (order_id, product_id)
                );


                Dipakai saat:

                Many-to-many

                Tidak perlu id auto increment

                F. DEFAULT Value

                Dipakai untuk:

                Nilai awal

                Data sistem

                status VARCHAR(20) DEFAULT 'pending'

                is_active BOOLEAN DEFAULT 1

                G. AUTO_INCREMENT (catatan penting)

                Hanya boleh satu per tabel

                Biasanya di Primary Key

                Jangan dipakai untuk data bisnis

                ‚ùå invoice_number AUTO_INCREMENT
                ‚úÖ id AUTO_INCREMENT

                H. ENGINE & CHARSET (LEVEL PRO)

                Kalau mau rapi:

                CREATE TABLE users (
                    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                    email VARCHAR(150) NOT NULL UNIQUE
                ) ENGINE=InnoDB
                CHARSET=utf8mb4;


                Kenapa?

                InnoDB ‚Üí support transaction & FK

                utf8mb4 ‚Üí emoji & karakter internasional

                I. Kesalahan Umum Pemula (hindari ini)

                ‚ùå Pakai TEXT untuk semua string
                ‚ùå Tidak pakai PK
                ‚ùå Semua kolom boleh NULL
                ‚ùå Nama kolom ambigu (data, value)

                J. Checklist CREATE TABLE (ingat ini)

                Sebelum execute, cek:

                Ada Primary Key?

                Tipe data pas?

                Kolom wajib pakai NOT NULL?

                Default value masuk akal?

                Nama konsisten?

                K. Mini Latihan üî•

                Coba desain tabel products dengan kebutuhan:

                id

                name

                price

                stock

                is_active

                created_at

                Tulis SQL-nya (versi kamu).
            </div>
        </main>
    </div>

    <script>
        fetch('layout/aside.html').then(response => response.text()).then(data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop();
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>