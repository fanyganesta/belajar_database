<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Type</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>

        <main>
            <header>
                
            </header>
            
            <div class="content">
                <h2>9.3 Integrasi dengan Framework (Production Mindset)</h2>

                Framework itu alat bantu,
                database itu sumber kebenaran.
                Kalau salah paham relasinya â†’ bug mahal.

                <br> <hr> <br>
                
                <h3>A. Apa Maksud â€œIntegrasi Frameworkâ€ Sebenarnya?</h3>

                Bukan cuma:

                connect DB

                bikin model

                query data

                Tapi:

                bagaimana framework mengatur cara kamu BERPIKIR soal data

                Framework:

                menyederhanakan

                menyembunyikan kompleksitas

                tapi juga bisa menipu kalau kamu terlalu percaya

                <br> <hr> <br>
                
                <h3>B. Peran Framework di Antara App & Database</h3>

                Struktur real-nya:

                [ Business Logic ]
                        â†“
                [ Framework Layer ]
                        â†“
                [ Database ]


                Framework bertugas:

                bikin developer cepat

                jaga konsistensi

                lindungi dari kesalahan dasar

                ğŸ“Œ Tapi bukan pengganti pemahaman SQL.

                <br> <hr> <br>
                
                <h3>C. Kenapa Integrasi Framework Jadi Masalah di Production?</h3>

                Karena di production:

                data besar

                query kompleks

                traffic tinggi

                scaling aktif

                Sedangkan framework:

                default untuk kasus umum

                bukan untuk edge case ekstrem

                ğŸ“Œ Di sinilah konflik muncul.

                <br> <hr> <br>
                
                <h3>D. Ilusi â€œORM Itu Amanâ€</h3>

                Pemula sering mikir:

                â€œPakai ORM = aman & performa okeâ€

                Faktanya:

                ORM = abstraction

                abstraction = tradeoff

                Framework tidak tahu konteks bisnis kamu.

                <br> <hr> <br>
                
                <h3>E. Tiga Level Integrasi Framework â†” DB</h3>

                Anggap ini tangga kematangan:

                1ï¸âƒ£ Convenience Level

                CRUD cepat

                developer senang

                performa cukup

                Ciri:

                User::all();
                Order::create([...]);


                Cocok:

                MVP

                admin sederhana

                2ï¸âƒ£ Control Level

                mulai mikir query

                sadar performa

                selective abstraction

                Ciri:

                DB::table('orders')
                ->select('id', 'total')
                ->where('status', 'paid')
                ->get();


                Cocok:

                production awal

                traffic naik

                3ï¸âƒ£ Ownership Level (Production Mindset)

                ngerti SQL

                ORM dipakai selektif

                query berat diatur manual

                Ciri:

                mix ORM + raw query

                explain query

                index-aware

                ğŸ“Œ Ini level engineer production.

                <br> <hr> <br>
                
                <h3>F. Framework â‰  Database Manager</h3>

                Kesalahan besar:
                âŒ nyerahin semua ke ORM
                âŒ nggak ngerti schema
                âŒ nggak ngerti index
                âŒ nggak ngerti execution plan

                Framework tidak menggantikan DBA mindset.

                <br> <hr> <br>
                
                <h3>G. Integrasi Framework Harus Sadar Arsitektur</h3>

                Framework harus tahu:

                read vs write

                replica vs master

                shard mana

                tenant mana

                Kalau tidak:

                framework jadi blind driver

                <br> <hr> <br>
                
                <h3>H. Integrasi yang Sehat (Checklist)</h3>

                âœ” framework aware read/write
                âœ” ORM tidak dipakai membabi buta
                âœ” raw query untuk heavy query
                âœ” transaksi jelas
                âœ” error handling jelas
                âœ” logging query aktif

                <br> <hr> <br>
                
                <h3>I. Kenapa Bab 9.3 Datang SETELAH Scaling?</h3>

                Karena:

                framework default = non-scaled

                scaling = arsitektur

                integrasi = adaptasi framework ke arsitektur

                ğŸ“Œ Framework HARUS menyesuaikan arsitektur, bukan sebaliknya.

                <br> <hr> <br>
                
                <h3>J. Ringkasan Inti BAB 9.3</h3>

                Framework bukan otak,
                tapi sarung tangan.

                Kalau:

                data kecil â†’ sarung tangan tipis

                data besar â†’ butuh kontrol tangan langsung

                <br> <br>

                <hr>

                <br> <br>

                <h2>9.3.1 ORM vs Raw Query (Bedah Tanpa Bias)</h2>

                ORM itu bukan salah.
                Raw Query juga bukan selalu benar.
                Yang salah itu: pakai tanpa sadar.

                <br> <hr> <br>

                <h3>A. Definisi Singkat (biar satu frekuensi)</h3>
                ğŸ”¹ ORM (Object Relational Mapping)

                Cara kerja:

                tabel â†’ object
                row â†’ instance

                Contoh (Laravel Eloquent):

                $user = User::where('email', $email)->first();

                ğŸ”¹ Raw Query

                Query SQL ditulis manual, dieksekusi langsung.

                $user = DB::select(
                    'SELECT * FROM users WHERE email = ?',
                    [$email]
                );

                <br> <hr> <br>

                <h3>B. Kenapa ORM Sangat Populer?</h3>

                Karena:

                cepat dikoding

                readable

                maintainable

                minim SQL knowledge

                ğŸ“Œ Cocok untuk developer speed.

                <br> <hr> <br>

                <h3>C. Ilusi Berbahaya dari ORM</h3>

                ORM bikin kamu lupa bahwa:

                DB tetap pakai SQL

                DB tetap pakai index

                DB tetap punya execution plan

                ORM menyembunyikan:

                query asli

                jumlah query

                join yang terjadi

                ğŸ“Œ Inilah sumber banyak bug production.

                <br> <hr> <br>

                <h3>D. Perbandingan Langsung (Jujur & Nyata)</h3>
                Aspek	ORM	Raw Query
                Kecepatan dev	â­â­â­â­	â­â­
                Kontrol query	â­â­	â­â­â­â­â­
                Performa	â­â­â€“â­â­â­	â­â­â­â­â­
                Debug SQL	âŒ	âœ”
                Scaling	âŒ	âœ”
                Aman SQL Injection	âœ” (default)	âš ï¸ (kalau ceroboh)

                <br> <hr> <br>

                <h3>E. Contoh Kasus Nyata (PENTING)</h3>
                Kasus 1: List User Sederhana
                User::where('active', 1)->get();


                âœ” ORM ideal
                âœ” clean
                âœ” cepat

                Kasus 2: Dashboard Laporan Berat
                SELECT DATE(created_at), COUNT(*)
                FROM orders
                GROUP BY DATE(created_at);


                âŒ ORM ribet
                âŒ sulit dioptimasi
                âœ” Raw Query jauh lebih jelas

                Kasus 3: N+1 Problem (JEBakan ORM)
                $orders = Order::all();

                foreach ($orders as $order) {
                    echo $order->user->name;
                }


                Yang terjadi:

                1 query ambil orders

                N query ambil user

                ğŸ“Œ ORM bikin ini terlihat aman padahal mahal.

                <br> <hr> <br>

                <h3>F. ORM Cocok untuk Apa?</h3>

                Gunakan ORM kalau:

                âœ” CRUD sederhana
                âœ” data kecilâ€“menengah
                âœ” logic bisnis jelas
                âœ” bukan query agregat berat
                âœ” butuh maintainability

                <br> <hr> <br>

                <h3>G. Raw Query Cocok untuk Apa?</h3>

                Gunakan Raw Query kalau:

                âœ” laporan berat
                âœ” agregasi kompleks
                âœ” join banyak
                âœ” tuning performa
                âœ” query critical path

                ğŸ“Œ Production systems pasti mix.

                <br> <hr> <br>

                <h3>H. Pola Sehat di Dunia Nyata</h3>

                ORM untuk transaksi,
                Raw Query untuk analitik.

                Contoh:

                create order â†’ ORM

                list dashboard â†’ raw SQL

                report bulanan â†’ raw SQL

                <br> <hr> <br>

                <h3>I. ORM + Raw Query (Bisa Hidup Bareng)</h3>

                Laravel mendukung:

                DB::select(...)
                DB::statement(...)
                DB::transaction(...)


                Dan tetap bisa:

                logging

                binding

                connection control

                <br> <hr> <br>

                <h3>J. Kesalahan Fatal Pemula</h3>

                âŒ anti raw query
                âŒ pakai ORM untuk semua
                âŒ nggak cek SQL hasil ORM
                âŒ ORM = performa

                ğŸ“Œ ORM bukan pengganti SQL.

                ğŸ§  Mental Model yang Harus Nempel

                ORM itu peta,
                SQL itu medan aslinya.

                Kalau medan sulit:

                kamu harus turun dari peta

                ğŸ”¥ Ringkasan Keras & Jujur

                ORM = cepat & nyaman

                Raw Query = kontrol & performa

                Production = kombinasi

                Jangan fanatik

                <br> <br>

                <hr> 

                <br> <br>
                
                <h2>9.3.2 Kapan ORM Berbahaya (Real Production Talk)</h2>

                ORM itu aman kalau kecil.
                Begitu sistem gede, ORM bisa jadi senjata makan tuan.

                Kita bahas bukan buat nakutin, tapi biar kamu pakai dengan sadar.

                <br> <hr> <br>

                <h3>A. ORM Tidak Tahu Konteks Production</h3>

                ORM itu:

                dibuat untuk kasus umum

                tidak tahu:

                data kamu jutaan

                query kamu kritikal

                DB kamu punya replica

                ada sharding / tenant

                ğŸ“Œ Jadi kalau kamu percaya 100% ke ORM â†’ bahaya

                <br> <hr> <br>

                <h3>B. Situasi ORM Mulai Berbahaya</h3>

                Kita masuk ke kasus nyata satu per satu ğŸ‘‡

                1ï¸âƒ£ Data Sudah BESAR

                Contoh polos:

                User::all();


                Di dev:

                100 row â†’ aman

                Di prod:

                10 juta row â†’ ğŸ’€

                ğŸ“Œ ORM tidak kasih peringatan.

                2ï¸âƒ£ N+1 Query Problem (Pembunuh Diam-Diam)
                $orders = Order::all();

                foreach ($orders as $order) {
                    echo $order->user->email;
                }


                Yang terjadi:

                1 query ambil orders

                N query ambil users

                ğŸ“Œ Ini paling sering bikin DB overload.

                3ï¸âƒ£ Eager Loading yang Salah Kaprah
                Order::with('items', 'user', 'payments')->get();


                Masalah:

                join besar

                data kebanyakan

                memory naik

                waktu query lama

                ğŸ“Œ Eager loading bukan obat semua penyakit.

                4ï¸âƒ£ ORM Menyembunyikan Query Asli

                Kamu nulis:

                Order::where('status', 'paid')->get();


                Yang DB lihat:

                SELECT * FROM orders WHERE status = 'paid';


                Masalah:

                SELECT *

                index belum tentu ada

                DB scan besar

                ORM tidak maksa kamu mikir index.

                5ï¸âƒ£ Pagination Palsu (OFFSET = MUSUH)
                Order::paginate(100);


                Di belakang:

                LIMIT 100 OFFSET 100000;


                OFFSET besar:

                DB tetap scan ribuan row

                makin halaman belakang â†’ makin lambat

                ğŸ“Œ ORM bikin ini kelihatan aman.

                6ï¸âƒ£ Transaction Tersembunyi

                ORM kadang:

                auto save

                auto update

                auto relationship sync

                Akibatnya:

                lock lama

                deadlock

                timeout random

                Dan kamu:

                â€œkok errornya nggak konsisten?â€

                7ï¸âƒ£ Tidak Sadar Read vs Write

                ORM:

                auto select

                auto save

                Kalau kamu pakai:

                read replica

                sharding

                ORM default tidak tahu konteks itu.

                ğŸ“Œ Bisa baca dari replica padahal data baru saja ditulis.

                <br> <hr> <br>

                <h3>C. ORM + Scaling = Harus Extra Disiplin</h3>

                Begitu:

                read replica aktif

                sharding aktif

                multi-tenant aktif

                ORM harus dikontrol:

                connection

                scope

                transaction

                query

                <br> <hr> <br>

                <h3>D. Ciri-Ciri ORM SUDAH KEBABLASAN</h3>

                Kalau kamu lihat:

                loading lama tanpa error

                CPU DB tinggi

                banyak query kecil

                sulit trace query

                â€œdi lokal cepat, di prod lambatâ€

                ğŸ“Œ 95% kasus = ORM misuse

                <br> <hr> <br>

                <h3>E. Cara Mengamankan ORM (Bukan Meninggalkannya)</h3>

                ORM tidak perlu dibuang, tapi:

                E.1 Batasi ORM ke Area Aman

                Gunakan ORM untuk:

                create / update entity

                simple lookup

                business logic inti

                E.2 Query Berat = Query Builder / Raw SQL
                DB::table('orders')
                ->select(DB::raw('DATE(created_at) as date, COUNT(*) as total'))
                ->groupBy('date')
                ->get();

                E.3 Selalu Sadari Jumlah Query

                Biasakan tanya:

                â€œIni nembak DB berapa kali?â€

                E.4 Gunakan Index-Aware Thinking

                ORM tidak peduli index, kamu harus peduli.

                <br> <hr> <br>

                <h3>F. Mental Model Penyelamat</h3>

                ORM itu asisten,
                bukan arsitek.

                Kalau:

                sistem kecil â†’ asisten oke

                sistem besar â†’ kamu harus pegang kemudi

                <br> <hr> <br>

                <h3>G. Ringkasan Keras & Jujur</h3>

                ORM berbahaya saat data besar

                ORM menipu rasa aman

                Scaling + ORM = disiplin ekstra

                Production = sadar SQL

                <br> <br>

                <hr>

                <br> <br>

                <h2>9.3.3 Laravel Query Builder â€” Deep Dive (Production-Oriented)</h2>

                Query Builder = kontrol SQL tanpa kehilangan kenyamanan framework

                Ini jembatan:

                dari ORM â†’ raw SQL

                dari â€œasal jalanâ€ â†’ sadar performa

                <br> <hr> <br>
                
                <h3>A. Posisi Query Builder di Mental Model</h3>

                Ingat tangga ini:

                ORM (Eloquent)
                â†“
                Query Builder   â† â­ KITA DI SINI
                â†“
                Raw SQL


                Query Builder:

                lebih eksplisit dari ORM

                lebih aman dari raw SQL

                masih readable

                ğŸ“Œ Production-friendly default.

                <br> <hr> <br>
                
                <h3>B. Kenapa Query Builder Sangat Penting di Production?</h3>

                Karena:

                kamu tahu persis query apa yang dikirim

                bisa optimasi

                bisa kontrol kolom

                bisa kontrol index

                cocok untuk read-heavy system

                <br> <hr> <br>
                
                <h3>C. Dasar yang Wajib Dipakai (Bukan Opsional)</h3>
                C.1 Hindari SELECT *

                âŒ Jangan:

                DB::table('orders')->get();


                âœ… Lakukan:

                DB::table('orders')
                ->select('id', 'user_id', 'total')
                ->where('status', 'paid')
                ->get();


                ğŸ“Œ Query kecil â†’ cepat â†’ DB sehat.

                C.2 WHERE + INDEX AWARE

                Biasakan:

                WHERE = kolom indexed

                JOIN = foreign key indexed

                Query Builder tidak peduli index, kamu yang harus.

                <br> <hr> <br>
                
                <h3>D. JOIN yang Aman & Terkontrol</h3>
                DB::table('orders')
                ->join('users', 'orders.user_id', '=', 'users.id')
                ->select(
                    'orders.id',
                    'users.email',
                    'orders.total'
                )
                ->where('orders.status', 'paid')
                ->get();


                ğŸ“Œ Lebih jelas dari ORM, lebih aman dari raw SQL.

                <br> <hr> <br>
                
                <h3>E. Aggregation (INI KEKUATAN UTAMA)</h3>
                DB::table('orders')
                ->selectRaw('DATE(created_at) as date, SUM(total) as revenue')
                ->groupBy('date')
                ->orderBy('date')
                ->get();


                âœ” dashboard
                âœ” laporan
                âœ” statistik

                ORM biasanya kalah telak di sini.

                <br> <hr> <br>
                
                <h3>F. Pagination yang Lebih Waras</h3>

                Hindari OFFSET besar.

                âŒ Default ORM
                Order::paginate(100);

                âœ… Keyset Pagination
                DB::table('orders')
                ->where('id', '>', $lastId)
                ->orderBy('id')
                ->limit(100)
                ->get();


                ğŸ“Œ Ini production-grade pagination.

                <br> <hr> <br>
                
                <h3>G. Transaction dengan Query Builder</h3>
                DB::transaction(function () {
                    DB::table('orders')->insert([...]);
                    DB::table('stocks')->decrement('qty', 1);
                });


                âœ” aman
                âœ” jelas
                âœ” atomic

                <br> <hr> <br>
                
                <h3>H. Read Replica & Query Builder</h3>

                Query Builder otomatis:

                SELECT â†’ replica

                WRITE â†’ master

                Kalau sticky = true, aman dari lag.

                ğŸ“Œ Lebih predictable dari ORM.

                <br> <hr> <br>
                
                <h3>I. Debugging & Visibility (WAJIB DIKETAHUI)</h3>
                I.1 Lihat SQL Asli
                $query = DB::table('orders')->where('status', 'paid');
                dd($query->toSql(), $query->getBindings());

                I.2 Logging Query (Production Safe)
                DB::listen(function ($query) {
                    logger($query->sql, $query->bindings);
                });


                ğŸ“Œ Ini bikin kamu benar-benar paham apa yang DB jalankan.

                <br> <hr> <br>
                
                <h3>J. Anti-Pattern (HINDARI)</h3>

                âŒ query di loop
                âŒ join berlebihan
                âŒ select kolom nggak dipakai
                âŒ raw SQL tanpa binding
                âŒ log semua query tanpa filter

                <br> <hr> <br>
                
                <h3>K. Kapan TURUN ke Raw SQL?</h3>

                Query Builder cukup untuk 80â€“90% kasus.

                Turun ke raw SQL kalau:

                window function

                CTE

                query sangat kompleks

                vendor-specific SQL

                ğŸ“Œ Jangan turun cuma karena malas belajar Query Builder.

                ğŸ§  Mental Model Penutup

                Query Builder itu â€œsetir manualâ€
                di mobil matic bernama Laravel.

                Kamu:

                tetap nyaman

                tapi bisa ngontrol arah

                ğŸ”¥ Ringkasan Bab 9.3

                ORM = cepat tapi berbahaya kalau kebablasan

                Raw SQL = kuat tapi riskan

                Query Builder = titik tengah production

                ğŸ¯ Kamu Sudah Sampai Level Ini

                Kalau kamu:

                paham arsitektur

                paham scaling

                paham ORM risk

                paham Query Builder

                ğŸ‘‰ kamu sudah mikir seperti engineer production, bukan sekadar coder ğŸ”¥
            </div>
        </main>
    </div>

    <script>
        fetch('layout/aside.html').then(response => response.text()).then(data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop();
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>