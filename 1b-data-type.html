<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Type</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <aside id="aside">

        </aside>

        <main>
            <header>
                
            </header>
            
            <div class="content">
                <h2>1.2 â€” Data Type (MySQL Spesifik)</h2>
                <h3>Apa itu Data Type? (Bukan Definisi Buku)</h3>

                <p>Data type adalah kontrak antara data, database, dan logika bisnis. <br> <br>

                Saat kamu memilih data type, kamu sedang berkata ke database:
                <ul>
                    <li>Data ini boleh seperti apa</li>
                    <li>Batasannya sampai mana</li>
                    <li>Cara menyimpannya bagaimana</li>
                    <li>Cara menghitung & membandingkannya bagaimana</li>
                </ul>

                ğŸ“Œ Data type = penjaga kualitas data</p>

                <br>

                <hr>

                <br>

                <h3>Kenapa Data Type Sangat Penting?</h3>

                <p>Kesalahan data type:
                <ul>
                    <li>Tidak kelihatan hari ini</li>
                    <li>Tapi meledak 6â€“12 bulan kemudian</li>
                </ul> <br>

                Contoh klasik:
                <ul>
                    <li>Harga pakai INT</li>
                    <li>Uang pakai FLOAT</li>
                    <li>Tanggal pakai VARCHAR</li>
                </ul> <br>

                ğŸ‘‰ Ini bom waktu.</p>

                <br>

                <hr>

                <br>

                <h3>Cara Berpikir yang Benar Saat Memilih Data Type</h3>

                <p>Setiap kolom, tanyakan:
                <ul>
                    <li>Data ini apa maknanya?</li>
                    <li>Apakah akan dihitung?</li>
                    <li>Apakah akan dibandingkan?</li>
                    <li>Apakah akan diurutkan?</li>
                    <li>Apakah akan membesar?</li>
                </ul> <br>

                Kalau kamu jawab ini dengan benar â†’ data type otomatis tepat.</p>

                <br>

                <hr>

                <br>

                <h3>1ï¸âƒ£ NUMERIC DATA TYPE</h3>

                <p><strong>(INT, BIGINT, DECIMAL)</strong></p>

                <div class="quote"><p>Numeric bukan cuma â€œangkaâ€, tapi makna angka.</p></div>

                <br>

                <hr>

                <br>

                <h4>A. INT â€” Angka Bulat Umum</h4>
                <p><strong>Apa itu INT?</strong></p>

                <div class="quote"><p>INT adalah tipe data untuk angka bulat dalam rentang tertentu.</p></div>

                <p>Range (signed):
                <ul>
                    <li>-2,147,483,648 sampai 2,147,483,647</li>
                </ul></p>

                <br>

                <hr>

                <br>
                

                <p><strong>Kapan Pakai INT?</strong></p>

                <p>Gunakan INT untuk:
                <ul>
                    <li>Primary Key</li>
                    <li>Counter</li>
                    <li>Quantity</li>
                    <li>Status numerik</li>
                    <li>ID relasi</li>
                </ul>

                <br>

                <hr>

                <br>

                Contoh:</p>
<pre>
    id <br>
    user_id <br>
    stock <br>
    quantity
</pre>
                <p>INT BUKAN untuk: <br> <br>

                âŒ Uang <br>
                âŒ Berat presisi <br>
                âŒ Nilai pecahan <br> <br></p>

                <p><strong>Kesalahan Umum</strong></p>
<pre>
    price INT
</pre>
                <p>âŒ Harga bukan sekadar angka <br>
                âŒ Harga butuh presisi</p>

                <br>

                <hr>

                <br>

                <h4>B. BIGINT â€” Angka Besar (Future Proof)</h4>
                <p><strong>Apa itu BIGINT?</strong></p>

                <div class="quote"><p>BIGINT adalah versi besar dari INT.</p></div>

                <p>Range:
                <ul>
                    <li>Â±9 quintillion (sangat besar)</li>
                </ul></p>

                <br>

                <hr>

                <br>
                

                <p><strong>Kapan Pakai BIGINT?</strong></p>

                <p>Gunakan BIGINT jika:
                <ul>
                    <li>Data akan sangat banyak</li>
                    <li>Sistem jangka panjang</li>
                    <li>ID publik / distributed system</li>
                </ul>
                <br> <br>

                <br>

                <hr>

                <br>
                Contoh:</p>
<pre>
    orders.id <br>
    transactions.id <br>
    logs.id
</pre>

                <p>ğŸ“Œ Untuk sistem bisnis serius â†’ BIGINT lebih aman</p>

                <br>

                <hr>

                <br>

                <p><strong>INT vs BIGINT (Mindset)</strong></p>
                <table>
                    <tr>
                        <th>Kriteria</th>
                        <th>INT</th>
                        <th>BIGINT</th>
                    </tr>
                    <tr>
                        <td>Aman jangka panjang</td>
                        <td>âŒ</td>
                        <td>âœ”ï¸</td>
                    </tr>
                    <tr>
                        <td>Lebih hemat storage</td>
                        <td>âœ”ï¸</td>
                        <td>âŒ</td>
                    </tr>
                    <tr>
                        <td>Umum dipakai</td>
                        <td>âœ”ï¸</td>
                        <td>âœ”ï¸</td>
                    </tr>
                </table>
                <br> <br>
                
                <p>ğŸ‘‰ Di MySQL modern, selisih storage jarang jadi masalah.</p>

                <br>

                <hr>

                <br>

                <h4>C. DECIMAL â€” Angka Presisi (WAJIB untuk Uang)</h4>
                <p><strong>Apa itu DECIMAL?</strong></p>

                <div class="quote"><p>DECIMAL menyimpan angka dengan presisi tetap.</p></div>

                <p>Format:</p>
<pre>
    DECIMAL(total_digit, decimal_digit)
</pre>

                <p>Contoh:</p>
<pre>
    DECIMAL(15,2)
</pre>

                <p>Artinya:
                <ul>
                    <li>Total 15 digit</li>
                    <li>2 digit di belakang koma</li>
                </ul></p>

                <br>

                <hr>

                <br>

                <p><strong>Kapan Wajib Pakai DECIMAL?</strong></p>
                <ul>
                    <li>Harga</li>
                    <li>Uang</li>
                    <li>Pajak</li>
                    <li>Diskon</li>
                    <li>Financial calculation</li>
                </ul>

                <p>ğŸ“Œ Tidak ada kompromi untuk ini.</p>

                <br>

                <hr>

                <br>

                <p><strong>Kenapa BUKAN FLOAT / DOUBLE?</strong></p>

                <p>Karena:
                <ul>
                    <li>Floating point error</li>
                    <li>Pembulatan tidak konsisten</li>
                    <li>Fatal untuk finance</li>
                </ul>

                <br> <br>

                <br>

                <hr>

                <br>

                Contoh error klasik:</p>
<pre>
    0.1 + 0.2 â‰  0.3
</pre>
                <p>Contoh Penggunaan yang Benar</p>
<pre>
    price DECIMAL(12,2)
    tax DECIMAL(5,2)
    discount DECIMAL(5,2)
</pre>

<br>

<hr>

<br>

                <p><strong>Kesalahan Fatal di Dunia Nyata</strong></p>

                <p>âŒ Pakai INT untuk rupiah <br>
                âŒ Pakai FLOAT untuk pajak <br>
                âŒ DECIMAL terlalu kecil <br> <br>

                Contoh salah:</p>
<pre>
    DECIMAL(5,2) â†’ maksimal 999.99
</pre>

                <p>ğŸš¨ Gaji direktur lewat.</p>

                <br>

                <hr>

                <br>

                <h3>Pola Pikir Penting (Expert Level)</h3>
                <h4>1ï¸âƒ£ ID â‰  Data Bisnis</h4>

                <ul>
                    <li>ID â†’ INT / BIGINT</li>
                    <li>Nilai bisnis â†’ DECIMAL</li>
                </ul>

                <br>

                <hr>

                <br>

                <h4>2ï¸âƒ£ Lebih Besar Lebih Aman (dalam batas wajar)</h4>

                <ul>
                    <li>BIGINT lebih aman dari INT</li>
                    <li>DECIMAL(15,2) lebih aman dari (8,2)</li>
                </ul>

                <br>

                <hr>

                <br>

                <h4>3ï¸âƒ£ Storage Murah, Data Rusak Mahal</h4>

                <div class="quote"><p>Jangan pelit di data type.</p></div>

                <br>

                <hr>

                <br>

                <h3>Mini Case (Refleksi)</h3>

                <p>Bayangkan:
                <ul>
                    <li>Sistem finance</li>
                    <li>5 tahun</li>
                    <li>1 juta transaksi / bulan</li>
                </ul> <br> <br>

                â“ Apa yang terjadi kalau:
                <ul>
                    <li>PK pakai INT?</li>
                    <li>Harga pakai FLOAT?</li>
                </ul> <br> <br>

                ğŸ‘‰ Jawabannya: migrasi menyakitkan.</p>

                <br>

                <hr>

                <br>

                <h3>Ringkasan 1.2 + Numeric</h3>
                <ul>
                    <li>Data type = kontrak data</li>
                    <li>INT â†’ angka bulat umum</li>
                    <li>BIGINT â†’ future-proof ID</li>
                    <li>DECIMAL â†’ WAJIB untuk uang</li>
                    <li>Salah pilih = utang teknis</li>
                </ul>

                <br>

                <br>

                <hr>

                <br>

                <br>


                <h2>1.2.2 â€” String Data Type</h2>

                <div class="quote"><p>VARCHAR vs TEXT (MySQL Spesifik)</p></div>     

                
                <br>

                <hr>

                <br>

                <h3>Kenapa String Itu Tidak â€œSekadar Teksâ€?</h3>

                <p>Banyak developer berpikir:

                <div class="quote"><p>â€œAh teks doang, pakai TEXT ajaâ€</p></div>

                Padahal di database:
                <ul>
                    <li>String mempengaruhi index</li>
                    <li>String mempengaruhi query speed</li>
                    <li>String mempengaruhi desain tabel</li>
                    <li>String mempengaruhi skalabilitas</li>
                </ul>
                
                ğŸ‘‰ Salah pilih = query makin lambat seiring waktu.</p>

                
                <br>

                <hr>

                <br>

                <h3>Cara Berpikir Awal (Mindset Penting)</h3>

                <p>Sebelum memilih VARCHAR atau TEXT, tanyakan:
                <ul>
                    <li>Apakah ini punya batas panjang yang jelas?</li>
                    <li>Apakah akan sering di-search / filter / join?</li>
                    <li>Apakah ini data utama atau data pelengkap?</li>
                </ul> <br>
                
                Jawaban ini menentukan data type, bukan kebiasaan.</p>

                
                <br>

                <hr>

                <br>

                <h3>A. VARCHAR â€” String yang Punya Batas & Tujuan</h3>
                
                <p>Apa itu VARCHAR?

                <div class="quote"><p>VARCHAR adalah string dengan panjang maksimal yang ditentukan.</p></div>

                <br> 

                Contoh:</p>
<pre>
    name VARCHAR(100) <br>
    email VARCHAR(150)
</pre>

                ğŸ“Œ Panjang fleksibel <br>
                ğŸ“Œ Tidak selalu pakai full size <br>
                ğŸ“Œ Bisa di-index penuh

                
                <br>

                <hr>

                <br>

                <h3>Kapan Wajib Pakai VARCHAR?</h3>

                <p>Gunakan VARCHAR untuk:
                <ul>
                    <li>Nama</li>
                    <li>Email</li>
                    <li>Username</li>
                    <li>Kode</li>
                    <li>Status teks pendek</li>
                </ul>
                <br>

                Contoh:</p>
<pre>
    name VARCHAR(100) <br>
    email VARCHAR(150) <br>
    sku VARCHAR(50) <br>
    status VARCHAR(20)
</pre>
                
                <br>

                <hr>

                <br>

                <h3>Kenapa VARCHAR Itu Sehat?</h3>
                <ul>
                    <li>Ada batasan jelas</li>
                    <li>Database bisa optimasi</li>
                    <li>Index bekerja optimal</li>
                    <li>Struktur tabel tetap ramping</li>
                </ul>
                
                <br>

                <hr>

                <br>

                <h3>Kesalahan Umum VARCHAR</h3>

                <p>âŒ VARCHAR Terlalu Panjang</p>
<pre>
    name VARCHAR(1000)
</pre>

                <p>Masalah:
                <ul>
                    <li>Tidak realistis</li>
                    <li>Index jadi berat</li>
                    <li>Menandakan desain tidak dipikirkan</li>
                </ul>
                

                âœ”ï¸ Lebih sehat:</p>
<pre>
    name VARCHAR(100)
</pre>
                
                <br>

                <hr>

                <br>

                <h3>B. TEXT â€” Konten Panjang (Bukan Default)</h3>
                
                <p>Apa itu TEXT?

                <div class="quote"><p>TEXT adalah string panjang tanpa batas kecil yang jelas.</p></div>

                Varian:
                <ul>
                    <li>TINYTEXT</li>
                    <li>TEXT</li>
                    <li>MEDIUMTEXT</li>
                    <li>LONGTEXT</li>
                </ul> <br>
                
                ğŸ“Œ Disimpan terpisah secara internal <br>
                ğŸ“Œ Tidak cocok untuk filter berat</p>

                
                <br>

                <hr>

                <br>

                <h3>Kapan TEXT Tepat Digunakan?</h3>

                <p>Gunakan TEXT untuk:
                <ul>
                    <li>Deskripsi panjang</li>
                    <li>Catatan</li>
                    <li>Konten artikel</li>
                    <li>HTML content</li>
                    <li>JSON besar (kalau terpaksa)</li>
                </ul> <br> <br>
                

                Contoh:</p>
<pre>
    description TEXT <br>
    notes TEXT <br>
    content LONGTEXT
</pre>
                
                <br>

                <hr>

                <br>

                <h3>TEXT BUKAN untuk:</h3>

                <p>âŒ Email <br>
                âŒ Status <br>
                âŒ Kode <br>
                âŒ Data yang sering di-join</p>

                
                <br>

                <hr>

                <br>

                <h3>VARCHAR vs TEXT (Perbandingan Kritis)</h3>
                <table>
                    <tr>
                        <th>Aspek</th>
                        <th>VARCHAR</th>
                        <th>TEXT</th>
                    </tr>
                    <tr>
                        <td>Batas panjang</td>
                        <td>Ada</td>
                        <td>Besar</td>
                    </tr>
                    <tr>
                        <td>Bisa di-index penuh</td>
                        <td>âœ”ï¸</td>
                        <td>âŒ(terbatas)</td>
                    </tr>
                    <tr>
                        <td>Performa filter</td>
                        <td>Cepat</td>
                        <td>Lebih lambat</td>
                    </tr>
                    <tr>
                        <td>Cocok untuk</td>
                        <td>Data inti</td>
                        <td>Konten</td>
                    </tr>
                </table>
                		
                <br>

                <hr>

                <br>
                
                <h3>Index & Dampak Besar (Sering Tidak Disadari)</h3>
<pre>
    email VARCHAR(150) â†’ index cepat <br>
    email TEXT â†’ index terbatas & berat
</pre>

                <p>ğŸ“Œ Banyak query lambat bukan karena JOIN, tapi karena TEXT.</p>

                
                <br>

                <hr>

                <br>

                <h3>Pola Kesalahan Dunia Nyata</h3>
                <p>âŒ Semua string = TEXT <br> <br>

                â†’ Query lambat <br>
                â†’ Index tidak optimal <br> <br>

                âŒ Semua string = VARCHAR(255) <br> <br>

                â†’ Desain asal <br>
                â†’ Tidak mencerminkan bisnis</p>

                
                <br>

                <hr>

                <br>

                <h3>Panjang VARCHAR: Cara Menentukan</h3>
                <table>
                    <tr>
                        <th>Data</th>
                        <th>Saran</th>
                    </tr>
                    <tr>
                        <td>Name</td>
                        <td>100</td>
                    </tr>
                    <tr>
                        <td>Email</td>
                        <td>150</td>
                    </tr>
                    <tr>
                        <td>Phone</td>
                        <td>20</td>
                    </tr>
                    <tr>
                        <td>Code</td>
                        <td>20-50</td>
                    </tr>
                    <tr>
                        <td>Slug</td>
                        <td>150</td>
                    </tr>
                </table>

                <br>

                <p>ğŸ“Œ Ini bukan dogma, tapi praktik sehat.</p>

                
                <br>

                <hr>

                <br>

                <h3>Tentang UTF-8 & Panjang</h3>

                <p>Ingat:
                <ul>
                    <li>MySQL pakai utf8mb4</li>
                    <li>1 karakter â‰  1 byte</li>
                </ul> <br>

                ğŸ‘‰ Tapi jangan mikir terlalu teknis dulu, fokus makna data.</p>

                
                <br>

                <hr>

                <br>

                <h3>Best Practice String (Expert Level)</h3>

                <p>1ï¸âƒ£ VARCHAR default, TEXT jika perlu <br>
                2ï¸âƒ£ Tentukan panjang berdasarkan makna bisnis <br>
                3ï¸âƒ£ TEXT = data pelengkap, bukan data inti <br>
                4ï¸âƒ£ Jangan jadikan TEXT sebagai FK / join key <br></p>

                <br>

                <hr>

                <br>

                <h3>Mini Case (Refleksi)</h3>

                <p>Kasus: Produk <br> <br>

                â“ Mana yang TEXT? <br>
                â“ Mana yang VARCHAR?</p>
<pre>
    name ? <br>
    sku ? <br>
    description ? <br>
    category ?
</pre>

                <p>Jawaban sehat:</p>
<pre>
    name VARCHAR(150) <br>
    sku VARCHAR(50) <br>
    category VARCHAR(100) <br>
    description TEXT
</pre>
                <br>

                <hr>

                <br>

                <h3>Ringkasan 1.2.2</h3>
                <ul>
                    <li>VARCHAR = string terkontrol</li>
                    <li>TEXT = konten panjang</li>
                    <li>TEXT bukan default</li>
                    <li>String mempengaruhi performa</li>
                    <li>Desain string = desain sistem</li>
                </ul>

                <br> <br>

                <hr>

                <br> <br>

                <h2>1.2.3 â€” Date & Time</h2>

                <p>DATE, DATETIME, TIMESTAMP (MySQL Spesifik)</p>

                <h3>Kenapa Date & Time Itu Rawan?</h3>

                <p>Karena:
                <ul>
                    <li>Waktu punya zona</li>
                    <li>Waktu bisa berubah konteks</li>
                    <li>Waktu sering dipakai untuk laporan & analisis</li>
                </ul>
                
                <br>

                Dan kesalahan kecil:

                <div class="quote"><p></div>â€œAh sama aja tanggalâ€</p>

                ğŸ‘‰ Bisa bikin laporan keuangan meleset.</p>

                <br> <hr> <br>

                <h3>Cara Berpikir Awal (Mindset Penting)</h3>

                <p>Sebelum pilih tipe waktu, tanyakan:
                <ul>
                    <li>Apakah saya butuh tanggal saja?</li>
                    <li>Apakah saya butuh tanggal + jam?</li>
                    <li>Apakah data ini terikat zona waktu?</li>
                    <li>Apakah data ini log / event?</li>
                </ul>
                
                Jawaban ini menentukan tipe data.</p>

                <br> <hr> <br>

                <h3>A. DATE â€” Tanggal Tanpa Waktu</h3>
                Apa itu DATE?

                <div class="quote"><p>DATE menyimpan tanggal saja (YYYY-MM-DD).</p></div>

                <p>ğŸ“Œ Tidak ada jam <br>
                ğŸ“Œ Tidak ada menit <br>
                ğŸ“Œ Tidak ada zona waktu</p>

                <br> <hr> <br>

                <h4>Kapan Pakai DATE?</h4>

                <p>Gunakan DATE untuk:
                <ul>
                    <li>Tanggal lahir</li>
                    <li>Tanggal invoice</li>
                    <li>Tanggal jatuh tempo</li>
                    <li>Periode bisnis</li>
                </ul>
                
                Contoh:</p>
<pre>
    birth_date DATE <br>
    invoice_date DATE <br>
    due_date DATE
</pre>

                <br> <hr> <br>

                <h4>DATE BUKAN untuk:</h4>

                <p>âŒ Log aktivitas <br>
                âŒ Timestamp transaksi <br>
                âŒ Data real-time</p>

                <br> <hr> <br>

                <h3>B. DATETIME â€” Tanggal + Jam (Netral Zona)</h3>
                Apa itu DATETIME?

                <div class="quote"><p>DATETIME menyimpan tanggal dan waktu, tanpa peduli zona waktu.</p></div>

                <p>Format:</p>
<pre>
    YYYY-MM-DD HH:MM:SS
</pre>

                <p>ğŸ“Œ Tidak otomatis konversi zona <br>
                ğŸ“Œ Disimpan apa adanya</p>

                <br> <hr> <br>

                <h4>Kapan Pakai DATETIME?</h4>

                <p>Gunakan DATETIME untuk:
                <ul>
                    <li>Waktu transaksi</li>
                    <li>Jadwal</li>
                    <li>Event bisnis</li>
                    <li>Data historis</li>
                </ul>

                <br> <hr> <br>
                
                Contoh:</p>
<pre>
    created_at DATETIME <br>
    paid_at DATETIME <br>
    scheduled_at DATETIME
</pre>

                <br> <hr> <br>

                <h4>Kelebihan DATETIME</h4>
                <ul>
                    <li>Stabil</li>
                    <li>Tidak tergantung timezone server</li>
                    <li>Aman untuk laporan historis</li>
                </ul>

                <br> <hr> <br>

                <h3>C. TIMESTAMP â€” Waktu Absolut (Zona Waktu Aktif)</h3>
                Apa itu TIMESTAMP? <br>

                <div class="quote"><p>TIMESTAMP menyimpan waktu absolut (UTC) dan otomatis dikonversi ke timezone server.</p></div>

                <p>ğŸ“Œ Disimpan sebagai UTC <br>
                ğŸ“Œ Ditampilkan sesuai timezone</p>

                <br> <hr> <br>

                <h4>Kapan Pakai TIMESTAMP?</h4>

                <p>Gunakan TIMESTAMP untuk:
                <ul>
                    <li>Log sistem</li>
                    <li>Audit trail</li>
                    <li>Event real-time</li>
                    <li>Tracking aktivitas user</li>
                </ul>

                <br> <hr> <br>
                
                Contoh:</p>
<pre>
    last_login TIMESTAMP <br>
    updated_at TIMESTAMP <br>
    activity_at TIMESTAMP
</pre>

                <br> <hr> <br>

                <h4>Bahaya TIMESTAMP (Kalau Tidak Paham)</h4>s

                <p>âŒ Server timezone berubah â†’ waktu ikut berubah <br>
                âŒ Data lama bisa tampak bergeser <br>
                âŒ Laporan bisa kacau <br> <br>

                ğŸ‘‰ TIMESTAMP powerful tapi berbahaya.</p>

                <br> <hr> <br>

                <h3>DATE vs DATETIME vs TIMESTAMP (Perbandingan)</h3>
                <table>
                    <tr>
                        <th>Aspek</th>
                        <th>DATE</th>
                        <th>DATETIME</th>
                        <th>TIMESTAMP</th>
                    </tr>
                    <tr>
                        <td>Simpan jam</td>
                        <td>âŒ</td>
                        <td>âœ”ï¸</td>
                        <td>âœ”ï¸</td>
                    </tr>
                    <tr>
                        <td>Zona waktu</td>
                        <tdâŒ></td>
                        <td>âŒ</td>
                        <td>âœ”ï¸</td>
                    </tr>
                    <tr>
                        <td>Cocok laporan</td>
                        <td>âœ”ï¸</td>
                        <td>âœ”ï¸</td>
                        <td>âš ï¸</td>
                    </tr>
                    <tr>
                        <td>Cocok log</td>
                        <td>âŒ</td>
                        <td>âš ï¸</td>
                        <td>âœ”ï¸</td>
                    </tr>
                </table>

                <br> <hr> <br>
                
                <h3>Kesalahan Paling Sering Terjadi</h3>
                <p>âŒ Semua pakai DATETIME <br>
                â†’ Padahal tanggal saja cukup <br> <br>

                âŒ Semua pakai TIMESTAMP <br>
                â†’ Zona waktu jadi masalah <br> <br>

                âŒ Tanggal disimpan sebagai VARCHAR <br>
                â†’ Filter & sorting rusak</p>

                <br> <hr> <br>

                <h3>Tentang created_at & updated_at</h3>

                <p>Best practice:</p>
<pre>
    created_at DATETIME <br>
    updated_at DATETIME
</pre>
 <br>
                <p>ğŸ“Œ Banyak framework default ke TIMESTAMP <br>
                ğŸ“Œ Tapi untuk sistem bisnis & finance â†’ DATETIME lebih aman</p>

                <br> <hr> <br>

                <h3>Date & Time untuk Laporan (Penting!)</h3>
                <ul>
                    <li>Filter bulanan <br>
                        Lebih mudah dengan DATE atau DATETIME</li>
                    <li>Filter jam <br>
                        Butuh DATETIME / TIMESTAMP</li>
                    <li>Rekap historis <br>
                        Hindari TIMESTAMP jika zona berubah</li>
                </ul>

                <br> <hr> <br>                

                <h3>Mini Case (Refleksi)</h3>

                <p>Kasus: Transaksi <br> <br>

                Pertanyaan:</p>
                <ul>
                    <li>Apakah saya perlu jam? â†’ Ya</li>
                    <li>Apakah timezone penting? â†’ Tidak</li>
                    <li>Apakah untuk laporan? â†’ Ya</li>
                </ul>
                
                <p>ğŸ‘‰ DATETIME adalah pilihan sehat</p>

                <br> <hr> <br>

                <h3>Pola Pikir Expert (Ringkas)</h3>

                <p>1ï¸âƒ£ Tanggal saja â†’ DATE <br>
                2ï¸âƒ£ Tanggal + jam (stabil) â†’ DATETIME <br>
                3ï¸âƒ£ Log & audit â†’ TIMESTAMP <br>
                4ï¸âƒ£ Jangan simpan waktu sebagai string</p>

                <br> <hr> <br>

                <h3>Ringkasan 1.2.3</h3>
                <ul>
                    <li>DATE = tanggal</li>
                    <li>DATETIME = waktu netral</li>
                    <li>TIMESTAMP = waktu absolut</li>
                    <li>Salah pilih = laporan salah</li>
                    <li>Timezone itu musuh tersembunyi</li>
                </ul>

                <br> <br>

                <hr>
                 
                <br> <br>

                <h2>1.2.4 â€” Boolean</h2>

                <div class="quote"><p>(TINYINT(1) di MySQL)</p></div>

                <br>

                <hr>

                <br>

                <h3>Kenapa Boolean Perlu Dibahas Serius?</h3>

                <div class="quote"><p>Karena banyak sistem rusak bukan oleh angka besarâ€¦ <br>
                tapi oleh status kecil yang maknanya tidak jelas ğŸ˜„</p></div>

                Contoh klasik:
                <ul>
                    <li>is_active</li>
                    <li>is_paid</li>
                    <li>is_deleted</li>
                </ul> <br>
                
                Kelihatannya simpel, tapi:
                <ul>
                    <li>Nilainya apa?</li>
                    <li>0 artinya apa?</li>
                    <li>Bisa lebih dari dua kondisi?</li>
                </ul>

                <br>

                <hr>

                <br>

                <h3>Fakta Penting: MySQL Tidak Punya BOOLEAN Sejati</h3>

                Di MySQL:
<pre>
    BOOLEAN = TINYINT(1)
</pre>

                Artinya:
                <ul>
                    <li>Disimpan sebagai angka</li>
                    <li>Nilai valid secara teknis: -128 sampai 127</li>
                    <li>Tapi secara logika: 0 atau 1</li>
                </ul>

                ğŸ“Œ BOOLEAN di MySQL itu alias, bukan tipe khusus.

                <br>

                <hr>

                <br>

                <h3>Cara Berpikir yang Benar tentang Boolean</h3>

                Boolean hanya boleh dipakai untuk kondisi yang benar-benar dua keadaan. <br> <br>

                Jika suatu kondisi:
                <ul>
                    <li>Bisa berkembang</li>
                    <li>Bisa punya lebih dari dua status</li>
                </ul> <br>
                
                ğŸ‘‰ JANGAN pakai boolean

                <br>

                <hr>

                <br>

                <h3>A. Kapan Boolean Tepat Digunakan?</h3>

                Gunakan TINYINT(1) untuk:
                <ul>
                    <li>Flag sederhana</li>
                    <li>Kondisi ya / tidak</li>
                    <li>Status biner permanen</li>
                </ul> <br> <br>

                Contoh:
<pre>
    is_active TINYINT(1) <br> 
    is_verified TINYINT(1) <br>
    is_deleted TINYINT(1) <br>
</pre> <br>

                Makna:
<pre>
    0 = tidak <br> <br>

    1 = ya
</pre> <br>
                ğŸ“Œ Simpel, jelas, aman.

                <br>

                <hr>

                <br>

                <h3>B. Kapan Boolean TIDAK Tepat?</h3> <br>
                âŒ Status Bertahap
<pre>
    is_paid
</pre> <br> <br>


                Masalah:
                <ul>
                    <li>unpaid</li>
                    <li>pending</li>
                    <li>paid</li>
                    <li>failed</li>
                </ul> <br>
                

                ğŸ‘‰ Ini bukan boolean, tapi status. <br> <br>

                âŒ Status Bisnis
<pre>
    is_shipped
</pre>

                Karena:
                <ul>
                    <li>belum diproses</li>
                    <li>diproses</li>
                    <li>dikirim</li>
                    <li>diterima</li>
                    <li>retur</li>
                </ul> <br>
                
                ğŸ‘‰ Boolean tidak cukup.

                <br>

                <hr>

                <br>

                <h3>Pola Salah yang Sering Terjadi</h3>
                âŒ Boolean Bertumpuk
<pre>
    is_paid <br> 
    is_shipped <br>
    is_completed
</pre> <br> <br>

                Masalah:
                <ul>
                    <li>Kombinasi tidak valid</li>
                    <li>Sulit validasi</li>
                    <li>Sulit laporan</li>
                </ul>

                <br>

                <hr>

                <br>

                <h3>Pola Benar untuk Status Kompleks</h3>

                Gunakan:
                <ul>
                    <li>ENUM (sementara)</li>
                    <li>Lookup Table (lebih sehat)</li>
                </ul> <br> <br>

                Contoh:
<pre>
    status ENUM('pending','paid','failed')
</pre> <br> <br>

                Atau:
<pre>
    status_id â†’ statuses.id
</pre>
 <br>
                ğŸ“Œ Kita akan bahas ini di submateri berikutnya.

                <br>

                <hr>

                <br>

                <h3>NULL pada Boolean? (Hati-hati)</h3>
<pre>
    is_active TINYINT(1) NULL
</pre> <br> <br>

                Artinya:
<pre>
    0 â†’ false <br> <br>

    1 â†’ true <br> <br>

    NULL â†’ ???
</pre> <br> <br>
                ğŸš¨ Ini sering bikin bug logika. <br> <br>

                âœ”ï¸ Best practice:
<pre>
    is_active TINYINT(1) NOT NULL DEFAULT 1
</pre>
                <br>

                <hr>

                <br>

                <h3>Boolean & Soft Delete</h3>

                Pola lama:
<pre>
    is_deleted TINYINT(1)
</pre> <br> <br>

                Pola modern:
<pre>
    deleted_at DATETIME NULL
</pre> <br> <br>

                ğŸ“Œ Lebih informatif <br>
                ğŸ“Œ Bisa tahu kapan dihapus <br>
                ğŸ“Œ Lebih aman audit

                <br>

                <hr>

                <br>

                <h3>Boolean & Index</h3>

                Boolean:
                <ul>
                    <li>Nilainya sedikit</li>
                    <li>Index sering tidak efektif</li>
                </ul> <br>
                
                ğŸ‘‰ Jangan berharap performa dari index boolean saja.

                <br>

                <hr>

                <br>

                <h3>Mini Case (Refleksi)</h3>

                Kasus:  <br> <br>

                â“ Mana boolean? <br>
                â“ Mana bukan?
<pre>
    is_paid ? <br>
    payment_status ? <br>
    is_active ?
</pre> <br> <br>

                Jawaban sehat:
<pre>
    is_active TINYINT(1) <br>
    payment_status â†’ ENUM / lookup table
</pre>
                <br>

                <hr>

                <br>

                <h3>Ringkasan 1.2.4</h3>
                <ul>
                    <li>MySQL boolean = TINYINT(1)</li>
                    <li>Hanya untuk dua kondisi</li>
                    <li>Jangan pakai boolean untuk status kompleks</li>
                    <li>Hindari NULL pada boolean</li>
                    <li>Status â‰  boolean</li>
                </ul>
                
                <br> <br>

                <hr>

                <br> <br>

                <h2>1.2.5 ENUM vs Lookup Table (âš ï¸ PENTING BANGET)</h2>

                <div class="quote"><p>Ini salah satu keputusan desain database paling sering salah kaprah.</p></div>

                <h3>A. Apa itu ENUM?</h3>

                <div class="quote"><p>ENUM adalah tipe data khusus MySQL yang isinya sudah ditentukan di level kolom.</p></div>

                <p>Contoh ENUM</p>
<pre>
    CREATE TABLE orders ( <br>
        id INT PRIMARY KEY, <br>
        status ENUM('pending', 'paid', 'shipped', 'cancelled') <br>
    );
</pre>

                <p>Artinya:
                <ul>
                    <li>Kolom status HANYA boleh berisi salah satu dari nilai tersebut</li>
                    <li>Tidak bisa insert nilai lain</li>
                </ul> <br> <br>
                
                Insert valid</p>
<pre>
    INSERT INTO orders (id, status) <br>
    VALUES (1, 'paid');
</pre>

                <p>Insert invalid âŒ</p>
<pre>
    INSERT INTO orders (id, status) <br>
    VALUES (2, 'refund'); -- ERROR
</pre>            

                <br> <hr> <br>

                <h3>B. Kelebihan ENUM</h3>

                <p>âœ… Simple & cepat
                <ul>
                    <li>Tidak perlu tabel tambahan</li>
                    <li>Cocok untuk data kecil & jarang berubah</li>
                </ul>
                <br>

                âœ… Data terkontrol
                <ul>
                    <li>Tidak bisa input nilai di luar pilihan</li>
                </ul>
                

                âœ… Hemat storage
                <ul>
                    <li>MySQL menyimpan ENUM sebagai angka internal</li>
                </ul></p>
                

                <br> <hr> <br>

                <h3>C. Kekurangan ENUM (INI YANG SERING DIABAIKAN)</h3>

                <p>âŒ Sulit dikembangkan
                <ul>
                    <li>Mau tambah value â†’ harus ALTER TABLE</li>
                </ul></p>
<pre>
    ALTER TABLE orders <br>
    MODIFY status ENUM('pending','paid','shipped','cancelled','refund');
</pre>

                <p>âŒ Tightly coupled dengan schema
                <ul>
                    <li>Logika bisnis â€œtertanamâ€ di struktur DB</li>
                    <li>Kurang fleksibel untuk sistem besar</li>
                </ul> <br>

                âŒ Kurang portable
                <ul>
                    <li>ENUM MySQL-specific</li>
                    <li>Pindah ke PostgreSQL? Ribet</li>
                </ul> <br>

                âŒ Tidak bisa attach metadata <br>
                Tidak bisa kasih:
                <ul>
                    <li>label display</li>
                    <li>urutan</li>
                    <li>warna status</li>
                    <li>deskripsi</li>
                </ul></p>
                
                <br> <hr> <br>

                <h3>D. Apa itu Lookup Table?</h3>

                <div class="quote"><p>Lookup table adalah tabel referensi terpisah untuk nilai yang berulang.</p></div>

                <p>Contoh Lookup Table</p>
<pre>
    CREATE TABLE order_statuses ( <br>
        id INT PRIMARY KEY, <br>
        code VARCHAR(20), <br>
        label VARCHAR(50) <br>
    ); <br> <br>

    INSERT INTO order_statuses VALUES <br>
    (1, 'pending', 'Menunggu Pembayaran'), <br>
    (2, 'paid', 'Sudah Dibayar'), <br>
    (3, 'shipped', 'Dikirim'), <br>
    (4, 'cancelled', 'Dibatalkan');
</pre>

<br>

                <p>Tabel utama</p>
<pre>
    CREATE TABLE orders ( <br>
        id INT PRIMARY KEY, <br>
        status_id INT, <br>
        FOREIGN KEY (status_id) REFERENCES order_statuses(id) <br>
    );
</pre>

                <br> <hr> <br>

                <h3>E. Kelebihan Lookup Table</h3>

                <p>âœ… Fleksibel
                <ul>
                    <li>Tambah status â†’ cukup INSERT</li>
                    <li>Tidak perlu alter struktur tabel besar</li>
                </ul> <br>

                âœ… Relasi jelas & scalable
                <ul>
                    <li>Cocok untuk aplikasi berkembang</li>
                </ul> <br>

                âœ… Bisa tambah metadata</p>
<pre>
    ALTER TABLE order_statuses <br>
    ADD color VARCHAR(20), <br>
    ADD is_active BOOLEAN;
</pre>

<br>
                <p>âœ… Clean secara arsitektur
                <ul>
                    <li>Logic bisnis di data, bukan di schema</li>
                </ul></p>
                

                <br> <hr> <br>

                <h3>F. Kekurangan Lookup Table</h3>

                <p>âŒ Lebih kompleks <br> <br>

                Harus JOIN</p>
<pre>
    SELECT o.id, s.label <br>
    FROM orders o <br>
    JOIN order_statuses s ON o.status_id = s.id;
</pre> <br>

                <p>âŒ Sedikit overhead
                <ul>
                    <li>Tapi ini tidak signifikan di sistem modern</li>
                </ul></p>

                <br> <hr> <br>

                <h3>G. ENUM vs Lookup â€” Perbandingan Cepat</h3>
                <table>
                    <tr>
                        <th>Aspek</th>
                        <th>ENUM</th>
                        <th>Lookup Table</th>
                    </tr>
                    <tr>
                        <td>Mudah dibuat</td>
                        <td class="ct">âœ…</td>
                        <td class="ct">âŒ</td>
                    </tr>
                    <tr>
                        <td>Mudah dikembangkan</td>
                        <td class="ct">âŒ</td>
                        <td class="ct">âœ…</td>
                    </tr>
                    <tr>
                        <td>Cocok skala besar</td>
                        <td class="ct">âŒ</td>
                        <td class="ct">âœ…</td>
                    </tr>
                    <tr>
                        <td>Bisa metadata</td>
                        <td class="ct">âŒ</td>
                        <td class="ct">âœ…</td>
                    </tr>
                    <tr>
                        <td>Portable DB</td>
                        <td class="ct">âŒ</td>
                        <td class="ct">âœ…</td>
                    </tr>
                    <tr>
                        <td>Best practice profesional</td>
                        <td class="ct">âŒ</td>
                        <td class="ct">âœ…</td>
                    </tr>
                </table>

                <br> <hr> <br>
                
                <h3>H. Kapan Pakai ENUM?</h3>

                <p>ENUM BOLEH dipakai jika: <br> <br>

                âœ… Nilai sangat terbatas <br>
                âœ… Tidak akan berubah <br>
                âœ… Tidak butuh metadata <br>
                âœ… Sistem kecil / internal <br> <br>

                Contoh ENUM yang aman</p>
<pre>
    gender ENUM('male','female') <br>
    day ENUM('mon','tue','wed','thu','fri')
</pre>
                <br> <hr> <br>

                <h3>I. Kapan HARUS Lookup Table?</h3>

                <p>Lookup Table WAJIB jika: <br> <br>

                ğŸš¨ Nilai bisa bertambah <br>
                ğŸš¨ Ada label tampilan <br>
                ğŸš¨ Ada urutan / warna / status aktif <br>
                ğŸš¨ Dipakai di banyak modul <br>
                ğŸš¨ Aplikasi bisnis nyata <br> <br>

                Contoh wajib lookup
                <ul>
                    <li>Status order</li>
                    <li>Role user</li>
                    <li>Payment method</li>
                    <li>Kategori produk</li>
                    <li>Level prioritas</li>
                </ul></p>

                <br> <hr> <br>
                

                <h3>J. Mindset Penting (ingat ini)</h3>
                <ul>
                    <li>ENUM = cepat sekarang, mahal nanti</li>
                    <li>Lookup = sedikit ribet sekarang, aman selamanya</li>
                </ul>
                
                <br>

                <p>Kalau kamu bangun sistem:
                <ul>
                    <li>UMKM â†’ ENUM masih oke</li>
                    <li>SaaS / ERP / bisnis berkembang â†’ lookup table</li>
                </ul></p>

                <a href="2a-ddl.html" class="btn-next">2a. DDL</a>

            </div>
        </main>
    </div>

    <script>
        fetch('layout/aside.html').then(response => response.text()).then(data => {
            document.getElementById('aside').innerHTML = data;

            const currentPage = window.location.pathname.split('/').pop();
            const links = document.querySelectorAll('aside a');

            links.forEach(link => {
                if(link.getAttribute('href') == currentPage){
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>